/**
 * Horizon Profiler Integration
 * Integrates with existing MACE application map and declination values
 * 
 * Dependencies:
 * - Existing map variable (window.map or global map)
 * - Existing declination values from omphalopsychicsingle.js (window.declinationSummerSolstice, etc.)
 * - jQuery
 * - Leaflet
 * - Chart.js
 * - JSZip
 */

(function() {
    'use strict';

    // Get map instance - use window.map if available, otherwise try global map
    const getMap = function() {
        if (window.map) return window.map;
        if (typeof map !== 'undefined') return map;
        throw new Error("Map instance not found. Ensure map is initialized before loading horizon.js");
    };

    // =================================================================
    // STELLARIUM EXPORTER
    // =================================================================
    window.HC_generateStellariumZip = function(profileData, gazetteerPoints, meta) {
        if (!window.JSZip) {
            alert("JSZip library not found. Please ensure it is included.");
            return;
        }

        const zip = new JSZip();
        const safeName = meta.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const folder = zip.folder(safeName);

        // 1. Generate landscape.ini
        const iniContent = 
`[landscape]
name = ${meta.name}
type = polygonal
author = ${meta.author}
description = Generated by Horizon Profiler at Lat: ${meta.lat.toFixed(5)}, Lng: ${meta.lng.toFixed(5)}, Elev: ${Math.round(meta.elev)}m
polygonal_horizon_list = horizon.txt
polygonal_angle_rotatez = 0
planet = Earth
latitude = ${meta.lat}
longitude = ${meta.lng}
altitude = ${Math.round(meta.elev)}
`;
        folder.file("landscape.ini", iniContent);

        // 2. Generate horizon.txt
        let horizonStr = "";
        if (profileData && profileData.length > 0) {
            profileData.forEach(pt => {
                horizonStr += `${pt.x.toFixed(4)} ${pt.y.toFixed(4)}\n`;
            });
        }
        folder.file("horizon.txt", horizonStr);

        // 3. Generate gazetteer.txt
        if (gazetteerPoints && gazetteerPoints.length > 0) {
            let gazStr = "";
            gazetteerPoints.forEach(pt => {
                gazStr += `${pt.az.toFixed(4)} ${pt.alt.toFixed(4)} ${pt.label}\n`;
            });
            folder.file("gazetteer.txt", gazStr);
        }

        // 4. Generate and Download Zip
        zip.generateAsync({type:"blob"})
        .then(function(content) {
            const a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = `${safeName}_landscape.zip`;
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(a.href), 100);
        })
        .catch(function(err) {
            console.error("Error generating zip:", err);
            alert("Failed to generate zip file: " + err.message);
        });
    };

    // =================================================================
    // PALETTE CONFIGURATION
    // =================================================================
    // CONFIG: Default Palette for Reset
    const HC_DEFAULT_PALETTE = [
        { "lim": 0, "rgb": [40, 117, 164] },
        { "lim": 50, "rgb": [106, 169, 106] },
        { "lim": 200, "rgb": [90, 183, 78] },
        { "lim": 250, "rgb": [36, 143, 71] },
        { "lim": 600, "rgb": [121, 143, 93] },
        { "lim": 1000, "rgb": [147, 151, 89] },
        { "lim": 1500, "rgb": [175, 184, 137] },
        { "lim": 3000, "rgb": [177, 194, 172] },
        { "lim": 9500, "rgb": [128, 128, 128] }
    ];

    // Current Palette (Mutable) - Deep copy of default to start
    var HC_COLOR_STOPS = JSON.parse(JSON.stringify(HC_DEFAULT_PALETTE));

    // =================================================================
    // HORIZON CALCULATIONS (Pure Logic)
    // =================================================================
    const HC_SCAN_RADIUS_KM = 200;

    function HC_loadTileImage(url) {
        return new Promise(resolve => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = url;
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
        });
    }

    function HC_getInterpolatedHeight(dem, latlng, mapInstance) {
        const pt = mapInstance.project(latlng, dem.zoom);
        const x = pt.x - dem.originPoint.x;
        const y = pt.y - dem.originPoint.y;
        if (x < 0 || x >= dem.width - 1 || y < 0 || y >= dem.width - 1) return null;
        const x0 = Math.floor(x);
        const y0 = Math.floor(y);
        const dx = x - x0;
        const dy = y - y0;
        const w = dem.width;
        const idx = y0 * w + x0;
        const h00 = dem.data[idx];
        const h10 = dem.data[idx+1];
        const h01 = dem.data[idx+w];
        const h11 = dem.data[idx+w+1];
        return (h00 * (1 - dx) + h10 * dx) * (1 - dy) + (h01 * (1 - dx) + h11 * dx) * dy;
    }

    // Hillshade Helper with DISCRETE BANDS (No gradient interpolation)
    function HC_getHillshadeColor(dem, lx, ly, h) {
        // Bounds check
        const w = dem.width;
        const x = Math.floor(lx);
        const y = Math.floor(ly);
        if (x < 1 || x >= w-1 || y < 1 || y >= w-1) return 'rgb(100,100,100)'; // Default grey

        const idx = y * w + x;
        
        // Heights for slope (using adjacent pixels for speed)
        const z_n = dem.data[idx - w];
        const z_s = dem.data[idx + w];
        const z_w = dem.data[idx - 1];
        const z_e = dem.data[idx + 1];

        // Slope components (dz/dx, dz/dy)
        const dzdx = (z_e - z_w) / 2.0; 
        const dzdy = (z_s - z_n) / 2.0;
        
        // Aspect & Slope
        const aspect = Math.atan2(dzdy, -dzdx);
        const slope = Math.atan(Math.sqrt(dzdx*dzdx + dzdy*dzdy));

        // Lighting (Sun NW at 45deg elevation)
        const azimuth = 315.0 * (Math.PI / 180.0);
        const altitude = 45.0 * (Math.PI / 180.0);

        // Lambertian reflectance
        let hillshade = (Math.sin(altitude) * Math.cos(slope)) + 
                        (Math.cos(altitude) * Math.sin(slope) * Math.cos(azimuth - aspect));
        
        hillshade = Math.max(0, hillshade); // Clamp

        // Hypsometric Tint (DISCRETE BANDS - No Interpolation)
        let baseColor = HC_COLOR_STOPS[HC_COLOR_STOPS.length-1].rgb; // Default to highest
        for (let i = 0; i < HC_COLOR_STOPS.length; i++) {
            if (h < HC_COLOR_STOPS[i].lim) {
                baseColor = HC_COLOR_STOPS[i].rgb;
                break;
            }
        }
        let r = baseColor[0], g = baseColor[1], b = baseColor[2];

        // Apply Hillshade Intensity to Color
        // Modified to be softer (0.6 ambient + 0.4 hillshade)
        const intensity = 0.6 + (hillshade * 0.4);
        r = Math.min(255, Math.floor(r * intensity));
        g = Math.min(255, Math.floor(g * intensity));
        b = Math.min(255, Math.floor(b * intensity));

        return `rgb(${r},${g},${b})`;
    }

    async function HC_fetchTerrainPatch(centerLatLng, zoom, radiusTiles, mapInstance, progressCallback) {
        const centerPoint = mapInstance.project(centerLatLng, zoom);
        const tileSize = 256;
        const centerX = Math.floor(centerPoint.x / tileSize);
        const centerY = Math.floor(centerPoint.y / tileSize);
        const tiles = [];
        const promises = [];
        const totalTiles = Math.pow((radiusTiles * 2 + 1), 2);
        let downloaded = 0;

        for (let x = centerX - radiusTiles; x <= centerX + radiusTiles; x++) {
            for (let y = centerY - radiusTiles; y <= centerY + radiusTiles; y++) {
                const elevUrl = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${zoom}/${x}/${y}.png`;
                promises.push(
                    HC_loadTileImage(elevUrl).then(elevImg => {
                        if(progressCallback) {
                            downloaded++;
                            progressCallback(downloaded, totalTiles);
                        }
                        if (elevImg) tiles.push({ x, y, elevImg });
                    })
                );
            }
        }
        await Promise.all(promises);
        if (tiles.length === 0) throw new Error("No data.");
        const gridWidth = (radiusTiles * 2 + 1) * tileSize;
        const canvas = document.createElement('canvas');
        canvas.width = gridWidth;
        canvas.height = gridWidth;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const originX = (centerX - radiusTiles) * tileSize;
        const originY = (centerY - radiusTiles) * tileSize;

        tiles.forEach(t => ctx.drawImage(t.elevImg, (t.x * tileSize) - originX, (t.y * tileSize) - originY));
        const rawElev = ctx.getImageData(0, 0, gridWidth, gridWidth).data;
        const floatData = new Float32Array(gridWidth * gridWidth);
        for (let i = 0, j = 0; i < rawElev.length; i += 4, j++) {
            floatData[j] = (rawElev[i] * 256 + rawElev[i+1] + rawElev[i+2] / 256) - 32768;
        }

        return { data: floatData, width: gridWidth, zoom: zoom, originPoint: new L.Point(originX, originY) };
    }

    // Fetch Z14 tiles for specific horizon points (calculated from low-res viewshed)
    // Includes a 500-meter buffer zone around each horizon point
    async function HC_fetchZ14TilesForHorizonPoints(horizonPoints, mapInstance, progressCallback) {
        const tileSize = 256;
        const zoom = 14;
        const bufferMeters = 500; // 500 meter buffer zone
        const tileSet = new Set(); // Use Set to avoid duplicate tiles
        const horizonTileMap = new Map(); // Map horizon point index to tile coordinates
        
        // For each horizon point, determine which Z14 tiles are within the 500m buffer zone
        horizonPoints.forEach((point, idx) => {
            if (!point.latlng) return;
            
            // Calculate meters per pixel at Z14 for this latitude
            const metersPerPx = 40075016 * Math.cos(point.latlng.lat * Math.PI / 180) / Math.pow(2, zoom + 8);
            const bufferPixels = bufferMeters / metersPerPx;
            
            const pointProj = mapInstance.project(point.latlng, zoom);
            
            // Calculate bounding box in pixel coordinates (500m buffer)
            const minX = pointProj.x - bufferPixels;
            const maxX = pointProj.x + bufferPixels;
            const minY = pointProj.y - bufferPixels;
            const maxY = pointProj.y + bufferPixels;
            
            // Determine tile range for the buffer zone
            const minTileX = Math.floor(minX / tileSize);
            const maxTileX = Math.floor(maxX / tileSize);
            const minTileY = Math.floor(minY / tileSize);
            const maxTileY = Math.floor(maxY / tileSize);
            
            // Add all tiles within the buffer zone
            for (let tx = minTileX; tx <= maxTileX; tx++) {
                for (let ty = minTileY; ty <= maxTileY; ty++) {
                    const tileKey = `${tx},${ty}`;
                    tileSet.add(tileKey);
                    
                    if (!horizonTileMap.has(tileKey)) {
                        horizonTileMap.set(tileKey, []);
                    }
                    horizonTileMap.get(tileKey).push({ idx, point, tileX: tx, tileY: ty });
                }
            }
        });
        
        const uniqueTiles = Array.from(tileSet).map(key => {
            const [x, y] = key.split(',').map(Number);
            return { x, y, key };
        });
        
        console.log(`Max Res: Downloading ${uniqueTiles.length} Z14 tiles for ${horizonPoints.length} horizon points (500m buffer zone)`);
        
        // Download tiles in chunks
        const CHUNK_SIZE = 50;
        const tiles = [];
        let downloaded = 0;
        
        for (let i = 0; i < uniqueTiles.length; i += CHUNK_SIZE) {
            const chunk = uniqueTiles.slice(i, i + CHUNK_SIZE);
            const chunkPromises = chunk.map(({x, y, key}) => {
                const elevUrl = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${zoom}/${x}/${y}.png`;
                return HC_loadTileImage(elevUrl).then(elevImg => {
                    if(progressCallback) {
                        downloaded++;
                        progressCallback(downloaded, uniqueTiles.length);
                    }
                    if (elevImg) {
                        tiles.push({ x, y, elevImg, key });
                    }
                });
            });
            await Promise.all(chunkPromises);
            await HC_yieldToBrowser();
        }
        
        // Create a tile lookup map for quick access
        const tileLookup = new Map();
        tiles.forEach(t => {
            tileLookup.set(t.key, t);
        });
        
        return { tiles, tileLookup, horizonTileMap, zoom, tileSize };
    }

    // Hybrid terrain fetcher for Max resolution: Z12 base + Z14 horizon ring (OLD - not used)
    async function HC_fetchHybridTerrain_OLD(centerLatLng, baseZoom, horizonZoom, horizonStartKm, scanRadiusKm, mapInstance, progressCallback) {
        // Fetch Z12 base terrain for full scan radius
        HC_updateStatus(`Downloading base terrain (Z${baseZoom})...`, true);
        const baseTileWidthKm = 40075 / Math.pow(2, baseZoom);
        const baseRadiusTiles = Math.ceil(scanRadiusKm / baseTileWidthKm);
        const baseTotalTiles = Math.pow((baseRadiusTiles * 2 + 1), 2);
        // Calculate horizon tiles count first (approximate, will be exact later)
        const horizonTileWidthKm = 40075 / Math.pow(2, horizonZoom);
        const horizonRadiusKm = scanRadiusKm - horizonStartKm;
        const horizonRadiusTiles = Math.ceil(horizonRadiusKm / horizonTileWidthKm);
        const fullRadiusTiles = Math.ceil(scanRadiusKm / horizonTileWidthKm);
        const totalHorizonTiles = Math.pow((fullRadiusTiles * 2 + 1), 2) - Math.pow((horizonRadiusTiles * 2 + 1), 2);
        const totalTiles = baseTotalTiles + totalHorizonTiles;
        
        const baseTerrain = await HC_fetchTerrainPatch(centerLatLng, baseZoom, baseRadiusTiles, mapInstance, (dl, tot) => {
            if(progressCallback) progressCallback(dl, totalTiles);
        });

        // Fetch Z14 horizon ring only (outer portion)
        HC_updateStatus(`Downloading horizon terrain (Z${horizonZoom})...`, true);
        
        // Process Z14 tiles in chunks to avoid memory issues
        const centerPoint = mapInstance.project(centerLatLng, horizonZoom);
        const tileSize = 256;
        const centerX = Math.floor(centerPoint.x / tileSize);
        const centerY = Math.floor(centerPoint.y / tileSize);
        
        // Only fetch tiles in the outer ring (horizon region)
        const horizonTiles = [];
        const promises = [];
        let downloaded = 0;
        
        // Process in chunks of 50 tiles at a time
        const CHUNK_SIZE = 50;
        const allTileCoords = [];
        
        for (let x = centerX - fullRadiusTiles; x <= centerX + fullRadiusTiles; x++) {
            for (let y = centerY - fullRadiusTiles; y <= centerY + fullRadiusTiles; y++) {
                // Check if tile is in horizon ring (outside inner radius)
                const dx = x - centerX;
                const dy = y - centerY;
                const distTiles = Math.sqrt(dx * dx + dy * dy);
                if (distTiles > horizonRadiusTiles && distTiles <= fullRadiusTiles) {
                    allTileCoords.push({ x, y });
                }
            }
        }
        
        // Log tile count for debugging
        console.log(`Max Res: Downloading ${allTileCoords.length} Z14 horizon tiles (ring from ${horizonStartKm}km to ${scanRadiusKm}km)`);
        console.log(`Base Z12 tiles: ${baseTotalTiles}, Horizon Z14 tiles: ${allTileCoords.length}, Total: ${baseTotalTiles + allTileCoords.length}`);
        
        // Process tiles in chunks
        for (let i = 0; i < allTileCoords.length; i += CHUNK_SIZE) {
            const chunk = allTileCoords.slice(i, i + CHUNK_SIZE);
            const chunkPromises = chunk.map(({x, y}) => {
                const elevUrl = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${horizonZoom}/${x}/${y}.png`;
                return HC_loadTileImage(elevUrl).then(elevImg => {
                    if(progressCallback) {
                        downloaded++;
                        progressCallback(baseTotalTiles + downloaded, totalTiles);
                    }
                    if (elevImg) horizonTiles.push({ x, y, elevImg });
                });
            });
            await Promise.all(chunkPromises);
            await HC_yieldToBrowser(); // Yield between chunks
        }
        
        if (horizonTiles.length === 0) {
            // No horizon tiles, return base terrain only
            return { base: baseTerrain, horizon: null, horizonZoom: horizonZoom, horizonStartKm: horizonStartKm };
        }
        
        // Create horizon DEM from tiles (smaller canvas, only horizon region)
        const horizonGridWidth = (fullRadiusTiles * 2 + 1) * tileSize;
        const horizonCanvas = document.createElement('canvas');
        horizonCanvas.width = horizonGridWidth;
        horizonCanvas.height = horizonGridWidth;
        const horizonCtx = horizonCanvas.getContext('2d', { willReadFrequently: true });
        const horizonOriginX = (centerX - fullRadiusTiles) * tileSize;
        const horizonOriginY = (centerY - fullRadiusTiles) * tileSize;

        horizonTiles.forEach(t => {
            horizonCtx.drawImage(t.elevImg, (t.x * tileSize) - horizonOriginX, (t.y * tileSize) - horizonOriginY);
        });
        
        // Extract horizon data in chunks to avoid memory issues
        const CHUNK_PIXELS = 1000000; // Process 1M pixels at a time
        const totalPixels = horizonGridWidth * horizonGridWidth;
        const horizonData = new Float32Array(totalPixels);
        
        for (let y = 0; y < horizonGridWidth; y += Math.ceil(Math.sqrt(CHUNK_PIXELS))) {
            const chunkHeight = Math.min(Math.ceil(Math.sqrt(CHUNK_PIXELS)), horizonGridWidth - y);
            const chunkData = horizonCtx.getImageData(0, y, horizonGridWidth, chunkHeight).data;
            const startIdx = y * horizonGridWidth;
            for (let i = 0, j = startIdx; i < chunkData.length; i += 4, j++) {
                horizonData[j] = (chunkData[i] * 256 + chunkData[i+1] + chunkData[i+2] / 256) - 32768;
            }
            await HC_yieldToBrowser(); // Yield between chunks
        }
        
        const horizonTerrain = {
            data: horizonData,
            width: horizonGridWidth,
            zoom: horizonZoom,
            originPoint: new L.Point(horizonOriginX, horizonOriginY),
            centerX: centerX,
            centerY: centerY,
            radiusTiles: fullRadiusTiles,
            innerRadiusTiles: horizonRadiusTiles
        };

        return { base: baseTerrain, horizon: horizonTerrain, horizonZoom: horizonZoom, horizonStartKm: horizonStartKm };
    }

    // Utility function to yield control to browser, allowing UI updates
    function HC_yieldToBrowser() {
        return new Promise(resolve => setTimeout(resolve, 0));
    }

    // Helper function to get elevation from Z14 tile for a specific lat/lng
    // Uses cached tile data for efficiency
    function HC_getZ14Elevation(latlng, z14Data, mapInstance) {
        if (!z14Data || !z14Data.tileLookup) return null;
        
        const zoom = z14Data.zoom;
        const tileSize = z14Data.tileSize;
        const pointProj = mapInstance.project(latlng, zoom);
        const tileX = Math.floor(pointProj.x / tileSize);
        const tileY = Math.floor(pointProj.y / tileSize);
        const tileKey = `${tileX},${tileY}`;
        
        const tile = z14Data.tileLookup.get(tileKey);
        if (!tile || !tile.elevImg) return null;
        
        // Get pixel coordinates within the tile
        const localX = pointProj.x - (tileX * tileSize);
        const localY = pointProj.y - (tileY * tileSize);
        
        const x0 = Math.floor(localX);
        const y0 = Math.floor(localY);
        if (x0 < 0 || x0 >= tileSize - 1 || y0 < 0 || y0 >= tileSize - 1) return null;
        
        // Use cached canvas if available, otherwise create one
        if (!tile.canvas) {
            tile.canvas = document.createElement('canvas');
            tile.canvas.width = tileSize;
            tile.canvas.height = tileSize;
            tile.ctx = tile.canvas.getContext('2d');
            tile.ctx.drawImage(tile.elevImg, 0, 0);
        }
        
        const dx = localX - x0;
        const dy = localY - y0;
        const imgData = tile.ctx.getImageData(x0, y0, 2, 2).data;
        
        // Bilinear interpolation
        const h00 = (imgData[0] * 256 + imgData[1] + imgData[2] / 256) - 32768;
        const h10 = (imgData[4] * 256 + imgData[5] + imgData[6] / 256) - 32768;
        const h01 = (imgData[tileSize * 4] * 256 + imgData[tileSize * 4 + 1] + imgData[tileSize * 4 + 2] / 256) - 32768;
        const h11 = (imgData[(tileSize + 1) * 4] * 256 + imgData[(tileSize + 1) * 4 + 1] + imgData[(tileSize + 1) * 4 + 2] / 256) - 32768;
        
        const h0 = h00 * (1 - dx) + h10 * dx;
        const h1 = h01 * (1 - dx) + h11 * dx;
        return h0 * (1 - dy) + h1 * dy;
    }

    async function HC_calculateViewshed(dem, centerLatLng, observerH, steps, mapInstance, hybridTerrain = null, suppressStatusUpdates = false) {
        const profile = [];
        // Use base DEM for coordinate calculations
        const baseDem = hybridTerrain ? hybridTerrain.base : dem;
        const centerPt = mapInstance.project(centerLatLng, baseDem.zoom);
        const maxDistKm = HC_SCAN_RADIUS_KM;
        const baseMetersPerPx = 40075016 * Math.cos(centerLatLng.lat * Math.PI / 180) / Math.pow(2, baseDem.zoom + 8);
        const maxPx = (maxDistKm * 1000) / baseMetersPerPx;
        const stepPx = 1;

        // For new hybrid terrain (Z14 tiles for horizon points), get Z14 data
        const z14Data = hybridTerrain && hybridTerrain.z14Data ? hybridTerrain.z14Data : null;
        const initialProfile = hybridTerrain && hybridTerrain.initialProfile ? hybridTerrain.initialProfile : null;
        
        // Create a map of horizon points by bearing for quick lookup
        const horizonPointMap = new Map();
        if (initialProfile && z14Data) {
            initialProfile.forEach((p, idx) => {
                if (p.latlng) {
                    const bearing = Math.round(p.x * 10) / 10; // Round to 0.1 degree for lookup
                    horizonPointMap.set(bearing, { latlng: p.latlng, idx });
                }
            });
        }

        // Astronomical horizon calculation constants
        // Using level surface through observer and ray curvature method
        const EARTH_RADIUS_METERS = 6371000; // Earth's mean radius in meters
        const REFRACTION_COEFFICIENT = 0.13; // Standard atmospheric refraction coefficient k
        // k ≈ 0.13 means ray curvature is about 13% of Earth's curvature
        // This accounts for atmospheric refraction bending light rays

        // Yield control every N steps to prevent UI freezing
        const YIELD_INTERVAL = Math.max(10, Math.floor(steps / 20)); // Yield ~20 times during calculation

        for (let i = 0; i < steps; i++) {
            const bearing = i * (360 / steps);
            const rad = (bearing - 90) * (Math.PI / 180);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            
            let maxAngle = -90;
            let horizonLatLng = null;
            const segments = [];
            let currentMaxAngle = -90; // Track current max for segment building
            let prevTerrainH = observerH;

            for (let r = 2; r < maxPx; r += stepPx) {
                const distMeters = r * baseMetersPerPx;
                const distKm = distMeters / 1000;
                
                // Use Z12 base DEM for all calculations
                // Z14 data will be used at specific horizon points via HC_getZ14Elevation
                const currentDem = baseDem;
                const currentMetersPerPx = baseMetersPerPx;
                const currentGlobalX = centerPt.x + (cos * r);
                const currentGlobalY = centerPt.y + (sin * r);
                const currentLocalX = currentGlobalX - currentDem.originPoint.x;
                const currentLocalY = currentGlobalY - currentDem.originPoint.y;
                
                // Check bounds
                if (currentLocalX < 0 || currentLocalX >= currentDem.width - 1 || currentLocalY < 0 || currentLocalY >= currentDem.width - 1) {
                    break;
                }

                const x0 = Math.floor(currentLocalX);
                const y0 = Math.floor(currentLocalY);
                const dx = currentLocalX - x0;
                const dy = currentLocalY - y0;
                const w = currentDem.width;
                const idx = y0 * w + x0;
                
                // Get terrain height - use Z14 if we're at a horizon point
                const bearingRounded = Math.round(bearing * 10) / 10;
                let terrainH;
                const horizonPoint = horizonPointMap.get(bearingRounded);
                
                // Check if current distance matches the horizon point distance (within tolerance)
                if (horizonPoint && z14Data && horizonPoint.latlng) {
                    const currentLatLng = mapInstance.unproject(new L.Point(currentGlobalX, currentGlobalY), baseDem.zoom);
                    const distToHorizonPoint = currentLatLng.distanceTo(horizonPoint.latlng) * 111; // km
                    
                    // If we're very close to the horizon point (within 2km), use Z14 elevation
                    if (distToHorizonPoint < 2) {
                        const z14Elev = HC_getZ14Elevation(horizonPoint.latlng, z14Data, mapInstance);
                        if (z14Elev !== null && !isNaN(z14Elev)) {
                            terrainH = z14Elev;
                        } else {
                            // Fallback to Z12 interpolation
                            const h00 = currentDem.data[idx];
                            const h10 = currentDem.data[idx + 1];
                            const h01 = currentDem.data[idx + w];
                            const h11 = currentDem.data[idx + w + 1];
                const h0 = h00 * (1 - dx) + h10 * dx;
                const h1 = h01 * (1 - dx) + h11 * dx;
                            terrainH = h0 * (1 - dy) + h1 * dy;
                        }
                    } else {
                        // Use Z12 interpolation
                        const h00 = currentDem.data[idx];
                        const h10 = currentDem.data[idx + 1];
                        const h01 = currentDem.data[idx + w];
                        const h11 = currentDem.data[idx + w + 1];
                        const h0 = h00 * (1 - dx) + h10 * dx;
                        const h1 = h01 * (1 - dx) + h11 * dx;
                        terrainH = h0 * (1 - dy) + h1 * dy;
                    }
                } else {
                    // Use Z12 base DEM interpolation
                    const h00 = currentDem.data[idx];
                    const h10 = currentDem.data[idx + 1];
                    const h01 = currentDem.data[idx + w];
                    const h11 = currentDem.data[idx + w + 1];
                    const h0 = h00 * (1 - dx) + h10 * dx;
                    const h1 = h01 * (1 - dx) + h11 * dx;
                    terrainH = h0 * (1 - dy) + h1 * dy;
                }
                
                // Astronomical horizon calculation using level surface through observer
                // The dip- and distance-formulae apply to any ray tangent to a spherical surface
                // We use a level surface through the observer, so the point of tangency is at the observer's eye
                // A horizontal ray at the observer appears at the observer's astronomical horizon
                
                // Calculate the height h of the astronomical horizon point H_H at distance d:
                // h = d²(1-k)/(2R)
                // where: d = distance in meters, k = refraction coefficient, R = Earth's radius
                const h = (distMeters * distMeters * (1 - REFRACTION_COEFFICIENT)) / (2 * EARTH_RADIUS_METERS);
                
                // The height of the astronomical horizon point H_H above the level surface:
                // H_H = H_obs + h
                const horizonHeight = observerH + h;
                
                // The angular altitude of the target point T above the observer's astronomical horizon:
                // angle = (H_target - H_H) / d radians
                // This is because the (assumed) constant lapse rate produces no image distortion
                const heightDifference = terrainH - horizonHeight;
                const angleRadians = heightDifference / distMeters;
                const angle = angleRadians * (180 / Math.PI); // Convert to degrees
                
                const distStepMeters = stepPx * currentMetersPerPx;
                const slope = (terrainH - prevTerrainH) / distStepMeters;
                prevTerrainH = terrainH;

                if (angle > currentMaxAngle) {
                    // Calculate color for hillshade rendering
                    const color = HC_getHillshadeColor(currentDem, currentLocalX, currentLocalY, terrainH);
                    segments.push({
                        top: angle,
                        bottom: currentMaxAngle,
                        dist: distMeters,
                        height: terrainH,
                        slope: slope,
                        lx: currentLocalX,
                        ly: currentLocalY,
                        color: color
                    });
                    currentMaxAngle = angle;
                    maxAngle = angle; // For the chart
                    
                    // Calculate horizon coordinates using spherical trigonometry (great circle path)
                    // This eliminates northward shift distortion caused by map projection
                    // Use destinationPoint instead of map projection unproject for accurate long-distance calculations
                    if (typeof LatLon !== 'undefined') {
                        const observerLatLon = new LatLon(centerLatLng.lat, centerLatLng.lng);
                        const destination = observerLatLon.destinationPoint(distMeters, bearing);
                        horizonLatLng = L.latLng(destination.lat, destination.lon);
                    } else {
                        // Fallback to map projection method if LatLon library not available
                        // Note: This will have distortion for long distances
                        horizonLatLng = mapInstance.unproject(new L.Point(currentGlobalX, currentGlobalY), currentDem.zoom);
                    }
                }
            }
            profile.push({ x: bearing, y: maxAngle, latlng: horizonLatLng, segments: segments });
            
            // Yield control periodically to allow UI updates
            if (i % YIELD_INTERVAL === 0 || i === steps - 1) {
                await HC_yieldToBrowser();
                // Update status periodically (only if not suppressed - e.g., for intervisibility calculations)
                if (!suppressStatusUpdates && i % (YIELD_INTERVAL * 2) === 0) {
                    HC_updateStatus(`Calculating Viewshed: ${Math.round((i / steps) * 100)}%`, true);
                }
            }
        }
        return profile;
    }

    // =================================================================
    // HORIZON CONTROLLER (Interaction & State)
    // =================================================================
    const HC_PEAK_FIND_ZOOM = 14;
    const HC_RES_SETTINGS = {
        'quick': { zoom: 11, steps: 360, name: 'Quick' },
        'hires': { zoom: 11, steps: 3600, name: 'Hi-Res' },
        'super': { zoom: 12, steps: 3600, name: 'Super' },
        'max':   { zoom: 14, steps: 3600, name: 'Max' }
    };

    // Internal State
    let HC_cachedTerrain = null;
    let HC_cachedParams = { center: null, height: 0 };
    let HC_profileData = [];
    let HC_currentProbeRes = 'quick'; // Track current probe resolution
    let HC_currentRiseSetRes = 'quick'; // Track current rise/set resolution
    let HC_lastAnalysisLatLng = null; // Store last analysis location for recalculation
    
    // Expose on window for export/import functions - use getters to always return current values
    Object.defineProperty(window, 'HC_cachedParams', {
        get: function() { return HC_cachedParams; },
        configurable: true
    });
    Object.defineProperty(window, 'HC_profileData', {
        get: function() { return HC_profileData; },
        configurable: true
    });
    
    // Setter functions for restore operations
    window.HC_setProfileData = function(data) {
        HC_profileData = data || [];
    };
    window.HC_setCachedParams = function(params) {
        if (params && typeof params === 'object') {
            HC_cachedParams = {
                center: params.center || null,
                height: params.height || 0
            };
        }
    };
    let HC_isPlacingMarker = false;
    let HC_panoBearing = 0;
    let HC_panoFov = 90;
    
    // Gazetteer State
    let HC_isGazetteerMode = false;
    let HC_gazetteerPoints = [];

    // Map Objects
    let HC_marker = null;
    let HC_polyline = null;
    let HC_chartInstance = null;
    let HC_showRiseSetLocations = false; // Toggle for showing rise/set locations
    
    // Rendering flags to prevent multiple simultaneous renders
    let HC_renderingPanorama = false;
    let HC_pendingPanoramaRender = false;
    
    // Initialization flags to prevent repeated setup
    let HC_declinationValuesSet = false;
    let HC_zeroHorizonAzimuthsSet = false;

    // Initialize when DOM is ready
    $(document).ready(function() {
        const map = getMap();

        // UI Handlers for separate resolution controls
        // Horizon Probe Resolution handlers
        $('.res-chk-probe').on('change', function() {
            if($(this).is(':checked')) {
                $('.res-chk-probe').not(this).prop('checked', false);
            } else {
                if($('.res-chk-probe:checked').length === 0) $('#res-probe-quick').prop('checked', true);
            }
        });
        
        // Rise/Set Resolution handlers with dependency check
        $('.res-chk-riseset').on('change', function() {
            if($(this).is(':checked')) {
                $('.res-chk-riseset').not(this).prop('checked', false);
                
                // Check dependency: if high res rise/set is selected, ensure high res probe is also selected
                const selectedRiseSetRes = $(this).attr('id');
                if(selectedRiseSetRes === 'res-riseset-hires' || selectedRiseSetRes === 'res-riseset-super' || selectedRiseSetRes === 'res-riseset-max') {
                    // Get the corresponding probe resolution
                    let requiredProbeRes = 'res-probe-quick';
                    if(selectedRiseSetRes === 'res-riseset-hires') requiredProbeRes = 'res-probe-hires';
                    else if(selectedRiseSetRes === 'res-riseset-super') requiredProbeRes = 'res-probe-super';
                    else if(selectedRiseSetRes === 'res-riseset-max') requiredProbeRes = 'res-probe-max';
                    
                    // Check if probe resolution is at least as high
                    const probeResOrder = { 'res-probe-quick': 0, 'res-probe-hires': 1, 'res-probe-super': 2, 'res-probe-max': 3 };
                    const riseSetResOrder = { 'res-riseset-quick': 0, 'res-riseset-hires': 1, 'res-riseset-super': 2, 'res-riseset-max': 3 };
                    const currentProbeRes = $('.res-chk-probe:checked').attr('id') || 'res-probe-quick';
                    
                    if(probeResOrder[currentProbeRes] < riseSetResOrder[selectedRiseSetRes]) {
                        // Auto-select matching probe resolution
                        $('#' + requiredProbeRes).prop('checked', true);
                        $('.res-chk-probe').not('#' + requiredProbeRes).prop('checked', false);
                        $('#res-riseset-warning').hide();
                    } else {
                        $('#res-riseset-warning').hide();
                    }
                } else {
                    $('#res-riseset-warning').hide();
                }
            } else {
                if($('.res-chk-riseset:checked').length === 0) $('#res-riseset-quick').prop('checked', true);
                $('#res-riseset-warning').hide();
            }
        });

        // Pano Navigation
        $('#pan-left').click(function() {
            HC_panoBearing = (HC_panoBearing - 20 + 360) % 360;
            setTimeout(() => HC_renderPanorama(), 50);
        });
        
        $('#pan-right').click(function() {
            HC_panoBearing = (HC_panoBearing + 20) % 360;
            setTimeout(() => HC_renderPanorama(), 50);
        });

        $('#btn-start').click(function() {
            HC_isPlacingMarker = true;
            $('#map').addClass('cursor-crosshair');
            HC_updateStatus("Click map to place marker...", true);
            $(this).addClass('disabled').text('Placing...');
        });

        // Go to Location button handler - uses draggable bigMarker
        $('#btn-go-to-location').click(function() {
            // Get lat/lon from the draggable bigMarker
            let lat, lng, latlng;
            
            if (typeof bigMarker !== 'undefined' && bigMarker) {
                // Use bigMarker if available
                latlng = bigMarker.getLatLng();
                lat = latlng.lat;
                lng = latlng.lng;
            } else if (typeof window.bigMarker !== 'undefined' && window.bigMarker) {
                // Try window.bigMarker as fallback
                latlng = window.bigMarker.getLatLng();
                lat = latlng.lat;
                lng = latlng.lng;
            } else {
                // Fallback to input fields if marker not available
                lat = parseFloat($('#hc-test-lat').val());
                lng = parseFloat($('#hc-test-lng').val());
                
                if (isNaN(lat) || isNaN(lng)) {
                    alert("Please ensure the bigMarker is available, or enter valid latitude and longitude values.");
                    return;
                }
                
                latlng = L.latLng(lat, lng);
            }
            
            if (isNaN(lat) || isNaN(lng)) {
                alert("Unable to get location from bigMarker. Please ensure bigMarker is available.");
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert("Latitude must be between -90 and 90 degrees.");
                return;
            }
            
            if (lng < -180 || lng > 180) {
                alert("Longitude must be between -180 and 180 degrees.");
                return;
            }
            
            const map = getMap();
            map.setView([lat, lng], 14);
            
            HC_setupProbeMarker(latlng).then(() => {
                setTimeout(() => {
                    if (HC_marker) {
                        HC_executeAnalysis(latlng);
                    }
                }, 500);
            });
        });

        // HOOK: Listen to click on map
        map.on('click', function(e) {
            if (HC_isGazetteerMode) {
                HC_handleGazetteerClick(e.latlng);
                return;
            }

            if(!HC_isPlacingMarker) return;

            HC_isPlacingMarker = false;
            $('#map').removeClass('cursor-crosshair');
            $('#btn-start').removeClass('disabled').html('<i class="fa fa-play"></i> Start Placement');

            HC_setupProbeMarker(e.latlng);
        });

        // Setup canvas interaction
        HC_setupCanvasInteraction('hc-panoCanvas', () => ({b:HC_panoBearing,f:HC_panoFov}), (b,f) => {HC_panoBearing=b; HC_panoFov=f;}, HC_renderPanorama);

        // Toggle results panel
        $('#btn-toggle-results').click(function() {
            const p = $('#hc-results-panel');
            p.toggleClass('minimized');
            $('#icon-toggle').attr('class', p.hasClass('minimized') ? 'fa fa-window-maximize' : 'fa fa-window-minimize');
        });

        // Initialize draggable gazetteer controls
        HC_makeDraggable('hc-gazetteer-controls');

        // Watch export modal checkbox
        $('#hc-export-gazetteer').change(function() {
            $('#hc-btn-proceed-export').text($(this).is(':checked') ? "Start Gazetteer Picking" : "Save Zip");
        });

        // Sync input fields with bigMarker position when marker is dragged
        function updateInputFieldsFromMarker() {
            let marker = null;
            if (typeof bigMarker !== 'undefined' && bigMarker) {
                marker = bigMarker;
            } else if (typeof window.bigMarker !== 'undefined' && window.bigMarker) {
                marker = window.bigMarker;
            }
            
            if (marker && $('#hc-test-lat').length && $('#hc-test-lng').length) {
                const latlng = marker.getLatLng();
                $('#hc-test-lat').val(latlng.lat.toFixed(6));
                $('#hc-test-lng').val(latlng.lng.toFixed(6));
            }
        }

        // Update input fields when bigMarker is dragged
        if (typeof bigMarker !== 'undefined' && bigMarker) {
            bigMarker.on('dragend', updateInputFieldsFromMarker);
            // Also update on initial load
            updateInputFieldsFromMarker();
        } else if (typeof window.bigMarker !== 'undefined' && window.bigMarker) {
            window.bigMarker.on('dragend', updateInputFieldsFromMarker);
            updateInputFieldsFromMarker();
        } else {
            // Try to set up listener after a short delay in case bigMarker is created later
            setTimeout(function() {
                if (typeof bigMarker !== 'undefined' && bigMarker) {
                    bigMarker.on('dragend', updateInputFieldsFromMarker);
                    updateInputFieldsFromMarker();
                } else if (typeof window.bigMarker !== 'undefined' && window.bigMarker) {
                    window.bigMarker.on('dragend', updateInputFieldsFromMarker);
                    updateInputFieldsFromMarker();
                }
            }, 1000);
        }
    });

    const HC_getProbeIcon = () => L.divIcon({ className: 'probe-icon', iconSize: [8, 8], iconAnchor: [4, 4] });

    async function HC_setupProbeMarker(latlng) {
        const map = getMap();
        if (HC_marker) map.removeLayer(HC_marker);
        HC_marker = L.marker(latlng, { icon: HC_getProbeIcon(), draggable: true }).addTo(map);
        
        HC_updateStatus("Sampling Elevation...", true);
        const obsData = await HC_fetchTerrainPatch(latlng, HC_PEAK_FIND_ZOOM, 1, map);
        let observerH = HC_getInterpolatedHeight(obsData, latlng, map) || 0;
        HC_updateStatus("Ready.", false);

        HC_bindMarkerPopup(HC_marker, latlng, observerH);

        HC_marker.on('dragend', async (e) => {
            const map = getMap();
            const newLL = e.target.getLatLng();
            const d = await HC_fetchTerrainPatch(newLL, HC_PEAK_FIND_ZOOM, 1, map);
            const h = HC_getInterpolatedHeight(d, newLL, map) || 0;
            HC_bindMarkerPopup(HC_marker, newLL, h);
            HC_marker.openPopup();
        });
        HC_marker.openPopup();
    }

    function HC_bindMarkerPopup(m, latlng, elev) {
        const content = `
            <div style="font-weight:bold; margin-bottom:5px;">Horizon Probe</div>
            <div>Lat: ${latlng.lat.toFixed(4)}</div>
            <div>Lng: ${latlng.lng.toFixed(4)}</div>
            <div style="margin-bottom:8px;">Elev: ${Math.round(elev)}m (+2m)</div>
            <button class="btn btn-primary btn-xs btn-block popup-btn" onclick="window.HC_triggerAnalysisFromProbe()">
                <i class="fa fa-calculator"></i> Calculate
            </button>
        `;
        m.bindPopup(content);
    }

    window.HC_triggerAnalysisFromProbe = function() {
        if(!HC_marker) return;
        HC_executeAnalysis(HC_marker.getLatLng());
        HC_marker.closePopup();
    };

    async function HC_executeAnalysis(latlng, resOverride = null) {
        // Hide buttons at start of new calculation
        $('#btn-view-horizon-results').hide();
        $('#btn-save-rise-set').hide();
        $('#btn-save-horizon-profile').hide();
        
        const map = getMap();
        let doProfile = $('#chk-profile').is(':checked');
        const doRiseSet = $('#chk-rise-set').is(':checked');
        
        console.log("HC_executeAnalysis: doProfile =", doProfile, "doRiseSet =", doRiseSet);
        console.log("Checkbox states: chk-profile =", $('#chk-profile').is(':checked'), "chk-rise-set =", $('#chk-rise-set').is(':checked'));

        if(!doProfile && !doRiseSet) {
            alert("Please select at least one action (Profile or Rise/Set).");
            return;
        }
        
        // When rise/set is selected, also run profile to create chart and visual horizon
        if (doRiseSet && !doProfile) {
            doProfile = true;
            $('#chk-profile').prop('checked', true);
        }

        if (HC_polyline) {
            map.removeLayer(HC_polyline);
            HC_polyline = null;
        }
        
        if (window.clearResultsDisplay) {
            window.clearResultsDisplay();
        }
        
        // Always clear old viewshed and rise/set results before new analysis
        window.HC_clearRiseSetResults();
        
        HC_profileData = [];

        // Get separate resolution keys for probe and rise/set
        let probeResKey = 'quick';
        if($('#res-probe-hires').is(':checked')) probeResKey = 'hires';
        else if($('#res-probe-super').is(':checked')) probeResKey = 'super';
        else if($('#res-probe-max').is(':checked')) probeResKey = 'max';
        
        let riseSetResKey = 'quick';
        if($('#res-riseset-hires').is(':checked')) riseSetResKey = 'hires';
        else if($('#res-riseset-super').is(':checked')) riseSetResKey = 'super';
        else if($('#res-riseset-max').is(':checked')) riseSetResKey = 'max';
        
        // For backward compatibility and resOverride
        let resKey = probeResKey;
        if(resOverride) {
            resKey = resOverride;
            probeResKey = resOverride;
            riseSetResKey = resOverride;
        }
        
        // Use probe resolution for profile calculations, riseSet resolution for rise/set calculations
        const config = HC_RES_SETTINGS[probeResKey];
        const riseSetConfig = HC_RES_SETTINGS[riseSetResKey];
        
        // Store current resolutions and location for recalculation
        HC_currentProbeRes = probeResKey;
        HC_currentRiseSetRes = riseSetResKey;
        HC_lastAnalysisLatLng = latlng;
        
        // Determine which resolution to use for initial calculation
        // If both profile and rise/set are selected, and rise/set resolution is lower than profile resolution,
        // we need to calculate at rise/set resolution first, then upgrade profile
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const probeResOrder = resOrder.indexOf(probeResKey);
        const riseSetResOrder = resOrder.indexOf(riseSetResKey);
        
        // For initial calculation: if rise/set is selected and its resolution is lower, use that for rise/set calculations
        // Otherwise use probe resolution for profile
        let initialResKey = probeResKey;
        let needsProfileUpgrade = false;
        
        if (doRiseSet && doProfile && riseSetResOrder < probeResOrder) {
            // Rise/set is at lower resolution, calculate at rise/set resolution first
            initialResKey = riseSetResKey;
            needsProfileUpgrade = true;
            HC_updateStatus(`Initializing ${riseSetConfig.name} analysis for rise/set calculations...`, true);
        } else {
            HC_updateStatus(`Initializing ${config.name} analysis...`, true);
        }
        
        const initialConfig = HC_RES_SETTINGS[initialResKey];

        if (doProfile || doRiseSet) {
            $('#hc-results-panel').css('display', 'flex').addClass('minimized');
            $('#icon-toggle').attr('class', 'fa fa-window-maximize');
        } else {
            $('#hc-results-panel').hide();
        }

        // HC_updateUpgradeControls removed - resolution controls are now at top of results panel

        try {
            const obsData = await HC_fetchTerrainPatch(latlng, HC_PEAK_FIND_ZOOM, 1, map);
            let observerH = HC_getInterpolatedHeight(obsData, latlng, map) || 0;

            // For Max resolution, use smart approach: calculate with Z12 first, then fetch Z14 tiles for horizon points only
            let hybridTerrain = null;
            if (initialResKey === 'max') {
                // First, fetch Z12 base terrain and calculate initial viewshed
                HC_updateStatus(`Downloading base terrain (Z12)...`, true);
                const baseTileWidthKm = 40075 / Math.pow(2, 12);
                const baseRadiusTiles = Math.ceil(HC_SCAN_RADIUS_KM / baseTileWidthKm);
                
                if (!HC_cachedTerrain || HC_cachedTerrain.zoom !== 12 || !HC_cachedParams.center || HC_cachedParams.center.distanceTo(latlng) > 1000) {
                    HC_cachedTerrain = await HC_fetchTerrainPatch(latlng, 12, baseRadiusTiles, map, (dl, tot) => {
                        HC_updateStatus(`Downloading Z12 tiles: ${dl}/${tot}`, true);
                    });
                }
                HC_cachedParams = { center: latlng, height: observerH + 2 };
                
                // Calculate initial viewshed with Z12 to find horizon points
                HC_updateStatus(`Calculating initial viewshed (Z12)...`, true);
                const initialProfile = await HC_calculateViewshed(HC_cachedTerrain, HC_cachedParams.center, HC_cachedParams.height, initialConfig.steps, map, null);
                
                // Extract horizon points (points with latlng)
                const horizonPoints = initialProfile.filter(p => p.latlng);
                
                if (horizonPoints.length > 0) {
                    // Fetch Z14 tiles only for actual horizon points
                    HC_updateStatus(`Downloading Z14 tiles for ${horizonPoints.length} horizon points...`, true);
                    const z14Data = await HC_fetchZ14TilesForHorizonPoints(horizonPoints, map, (dl, tot) => {
                        HC_updateStatus(`Downloading Z14 tiles: ${dl}/${tot}`, true);
                    });
                    hybridTerrain = { base: HC_cachedTerrain, z14Data: z14Data, initialProfile: initialProfile };
                    HC_cachedTerrain.hybrid = hybridTerrain;
                } else {
                    // No horizon points found, use Z12 only
                    hybridTerrain = null;
                }
            } else {
            HC_updateStatus(`Downloading Terrain (Z${initialConfig.zoom})...`, true);
            const tileWidthKm = 40075 / Math.pow(2, initialConfig.zoom);
            const radiusTiles = Math.ceil(HC_SCAN_RADIUS_KM / tileWidthKm);
            
            if (!HC_cachedTerrain || HC_cachedTerrain.zoom !== initialConfig.zoom || !HC_cachedParams.center || HC_cachedParams.center.distanceTo(latlng) > 1000) {
                HC_cachedTerrain = await HC_fetchTerrainPatch(latlng, initialConfig.zoom, radiusTiles, map, (dl, tot) => {
                    HC_updateStatus(`Downloading tiles: ${dl}/${tot}`, true);
                });
                    // Clear hybrid if switching away from Max
                    if (HC_cachedTerrain.hybrid) delete HC_cachedTerrain.hybrid;
                }
            }
            HC_cachedParams = { center: latlng, height: observerH + 2 };

            HC_updateStatus(`Calculating Viewshed (${initialConfig.steps} steps)...`, true);
            
            setTimeout(async () => {
                // Re-check checkbox state inside setTimeout to ensure we have current value
                const currentDoRiseSet = $('#chk-rise-set').is(':checked');
                const currentDoProfile = $('#chk-profile').is(':checked');
                console.log("Inside setTimeout: currentDoRiseSet =", currentDoRiseSet, "currentDoProfile =", currentDoProfile, "doRiseSet =", doRiseSet, "doProfile =", doProfile);
                
                const profile = await HC_calculateViewshed(HC_cachedTerrain, HC_cachedParams.center, HC_cachedParams.height, initialConfig.steps, map, hybridTerrain);
                HC_profileData = profile;

                // Use current checkbox state, fallback to captured variable
                const shouldCalculateRiseSet = currentDoRiseSet !== undefined ? currentDoRiseSet : doRiseSet;
                const shouldDoProfile = currentDoProfile !== undefined ? currentDoProfile : doProfile;

                if (shouldDoProfile) {
                    // Only draw viewshed on map if rise/set calculations are not also selected
                    // (hwtip.js will draw it when doRiseSet is true to avoid duplication)
                    if (!shouldCalculateRiseSet) {
                        HC_drawMapLine(profile);
                    }
                    HC_renderChart(profile);
                    HC_ensureCSVButton(); // Ensure CSV button is visible after chart is rendered
                    HC_panoBearing = 0;
                    
                    // Update visibility based on checkboxes first
                    if ($('#chk-show-chart').is(':checked')) {
                        $('#row-horizon-chart').show();
                    } else {
                        $('#row-horizon-chart').hide();
                    }
                    if ($('#chk-show-silhouette').is(':checked')) {
                        $('#row-visual-horizon-silhouette').show();
                    } else {
                        $('#row-visual-horizon-silhouette').hide();
                    }
                    if ($('#chk-show-hillshade').is(':checked')) {
                        $('#row-visual-horizon-hillshade').show();
                    } else {
                        $('#row-visual-horizon-hillshade').hide();
                    }
                    
                    // Ensure rise/set overlays are not shown by default when visual horizons are created
                    HC_showRiseSetLocations = false;
                    // Update button states
                    $('#btn-show-rise-set-silhouette, #btn-show-rise-set-hillshade').each(function() {
                        $(this).removeClass('btn-success').addClass('btn-info');
                        $(this).html('<i class="fa fa-map-marker"></i> Show Rise/Set Locations');
                    });
                    
                    // Render panoramas after visibility is set, with delay to ensure DOM is updated
                    // Use single requestAnimationFrame to avoid multiple renders
                    requestAnimationFrame(() => {
                        HC_renderPanorama();
                        // Show View Horizon Results button when horizon calculation completes
                        $('#btn-view-horizon-results').show();
                        // Update resolution controls after panorama render
                        HC_updateResolutionControls();
                    });
                } else {
                    const ctx = document.getElementById('hc-horizonChart').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    if (HC_chartInstance) {
                        HC_chartInstance.destroy();
                        HC_chartInstance = null;
                    }
                    const ctxPano = document.getElementById('hc-panoCanvas').getContext('2d');
                    ctxPano.clearRect(0, 0, ctxPano.canvas.width, ctxPano.canvas.height);
                }

                console.log("About to check rise/set: shouldCalculateRiseSet =", shouldCalculateRiseSet);
                
                if (shouldCalculateRiseSet) {
                    if (shouldDoProfile) {
                        HC_updateStatus("Horizon Probe Complete. Rise/Set Calculations Started.", true);
                    } else {
                        HC_updateStatus("Rise/Set Calculations Started.", true);
                    }
                    console.log("Rise/Set Calculation started. Using Profile Data:", HC_profileData);
                    console.log("shouldCalculateRiseSet:", shouldCalculateRiseSet, "shouldDoProfile:", shouldDoProfile, "profile length:", profile ? profile.length : 0, "latlng:", latlng);
                    if (!profile || profile.length === 0) {
                        console.error("No profile data available for rise/set calculation!");
                        HC_updateStatus("Error: No profile data available for rise/set calculation.", false);
                    } else {
                        console.log("Calling HC_calculateRiseSetLocations...");
                        await HC_calculateRiseSetLocations(latlng, profile);
                        console.log("HC_calculateRiseSetLocations completed");
                    }
                    
                    // If profile needs to be upgraded (e.g., rise/set was quick but profile should be hi-res)
                    if (needsProfileUpgrade) {
                        HC_updateStatus(`Upgrading profile to ${config.name} resolution...`, true);
                        // Recalculate profile at higher resolution
                        await HC_recalculateProfileInternal(latlng, probeResKey);
                    }
                } else {
                    HC_updateStatus("Horizon Probe Complete.", false);
                }
                
                // Update resolution display and buttons
                HC_updateResolutionControls();
            }, 100);

        } catch (err) {
            console.error(err);
            alert("Error: " + err.message);
            HC_updateStatus("Error occurred.", false);
        }
    }

    // GAZETTEER LOGIC
    function HC_openExportModal() {
        $('#hc-export-modal').modal('show');
        $('#hc-btn-proceed-export').text($('#hc-export-gazetteer').is(':checked') ? "Start Gazetteer Picking" : "Save Zip");
    }

    function HC_proceedExport() {
        const hasGazetteer = $('#hc-export-gazetteer').is(':checked');
        $('#hc-export-modal').modal('hide');

        if (hasGazetteer) {
            HC_startGazetteerMode();
        } else {
            HC_runExport();
        }
    }

    function HC_makeDraggable(elmId) {
        var elm = document.getElementById(elmId);
        var header = elm ? elm.querySelector("h5") : null;
        if (!header) return;
        
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        header.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            elm.style.top = (elm.offsetTop - pos2) + "px";
            elm.style.left = (elm.offsetLeft - pos1) + "px";
            elm.style.right = "auto";
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }

    function HC_startGazetteerMode() {
        HC_isGazetteerMode = true;
        HC_gazetteerPoints = [];
        $('#hc-gaz-list').empty();
        $('#hc-gazetteer-controls').show();
        $('#map').css('cursor', 'crosshair');
        HC_updateStatus("Click map features to add to gazetteer.", true);
    }

    async function HC_handleGazetteerClick(latlng) {
        const map = getMap();
        if (!HC_marker) { alert("Observer not defined."); return; }
        
        $('#map').css('cursor', 'wait');
        try {
            const obsLL = HC_marker.getLatLng();
            const d = await HC_fetchTerrainPatch(latlng, HC_PEAK_FIND_ZOOM, 1, map);
            const targetH = HC_getInterpolatedHeight(d, latlng, map) || 0;
            
            const obsH = HC_cachedParams.height || 0;
            const azAlt = HC_calculateAzAlt(obsLL, obsH, latlng, targetH);
            
            const popupContent = `
                <div class="form-group" style="margin-bottom:5px;">
                    <label>Feature Name:</label>
                    <input type="text" id="hc-gaz-name-input" class="form-control input-sm" autofocus>
                </div>
                <div style="font-size:10px; margin-bottom:5px; color:#666;">
                    Az: ${azAlt.az.toFixed(2)}°, Alt: ${azAlt.alt.toFixed(2)}°
                </div>
                <button class="btn btn-primary btn-xs btn-block" onclick="window.HC_addGazetteerPoint(${azAlt.az}, ${azAlt.alt}, '${latlng.lat},${latlng.lng}')">Add</button>
            `;
            
            L.popup()
                .setLatLng(latlng)
                .setContent(popupContent)
                .openOn(map);

        } catch (e) {
            console.error(e);
        } finally {
            $('#map').css('cursor', 'crosshair');
        }
    }

    function HC_calculateAzAlt(obsLL, obsH, targetLL, targetH) {
        const R = 6371000;
        const dLat = (targetLL.lat - obsLL.lat) * Math.PI / 180;
        const dLon = (targetLL.lng - obsLL.lng) * Math.PI / 180;
        const lat1 = obsLL.lat * Math.PI / 180;
        const lat2 = targetLL.lat * Math.PI / 180;

        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const dist = R * c;

        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) -
                  Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        let brng = Math.atan2(y, x) * 180 / Math.PI;
        brng = (brng + 360) % 360;

        const drop = (dist * dist) / (2 * R);
        const relH = (targetH - drop) - obsH;
        const alt = Math.atan2(relH, dist) * 180 / Math.PI;

        return { az: brng, alt: alt };
    }

    window.HC_addGazetteerPoint = function(az, alt, llStr) {
        const map = getMap();
        const name = $('#hc-gaz-name-input').val();
        if (!name) return;
        
        HC_gazetteerPoints.push({ label: name, az: az, alt: alt });
        $('#hc-gaz-list').append(`<li><b>${name}</b> (${az.toFixed(1)}°)</li>`);
        map.closePopup();
    };

    function HC_cancelGazetteer() {
        HC_isGazetteerMode = false;
        $('#hc-gazetteer-controls').hide();
        $('#map').css('cursor', 'default');
        HC_updateStatus("Gazetteer cancelled.", false);
    }

    function HC_finishGazetteer() {
        HC_isGazetteerMode = false;
        $('#hc-gazetteer-controls').hide();
        $('#map').css('cursor', 'default');
        HC_runExport();
    }

    window.HC_cancelGazetteer = HC_cancelGazetteer;
    window.HC_finishGazetteer = HC_finishGazetteer;

    function HC_runExport() {
        const meta = {
            name: $('#hc-export-name').val() || "Horizon",
            author: $('#hc-export-author').val() || "Unknown",
            lat: HC_marker ? HC_marker.getLatLng().lat : 0,
            lng: HC_marker ? HC_marker.getLatLng().lng : 0,
            elev: HC_cachedParams.height || 0
        };

        if (window.HC_generateStellariumZip) {
            window.HC_generateStellariumZip(HC_profileData, HC_gazetteerPoints, meta);
        } else {
            alert("Exporter script not loaded.");
        }
    }

    function HC_ensureCSVButton() {
        const container = $('#res-upgrade-controls');
        // Check if CSV button already exists
        if (container.find('button:contains("Export to CSV")').length === 0) {
            container.append('<button class="btn btn-xs btn-warning" onclick="if(typeof window.HC_exportChartToCSV === \'function\') { window.HC_exportChartToCSV(); } else { alert(\'Export function not available.\'); }"><i class="fa fa-download"></i> Export to CSV</button>');
        }
    }

    function HC_updateUpgradeControls(currentRes) {
        // This function is deprecated - resolution controls are now at top of results panel
        // Clear any old recalculate buttons that might have been added
        const container = $('#res-upgrade-controls');
        // Only keep the CSV export button, remove any recalculate buttons
        const existingButtons = container.find('button');
        existingButtons.each(function() {
            const btnText = $(this).text().toLowerCase();
            // Remove any buttons that say "Recalc" or "Recalculate"
            if (btnText.includes('recalc') || btnText.includes('recalculate')) {
                $(this).remove();
            }
        });
        // Ensure CSV export button is still there
        HC_ensureCSVButton();
    }

    window.HC_triggerUpgrade = function(resKey) {
        if(!HC_marker) return;
        HC_executeAnalysis(HC_marker.getLatLng(), resKey);
    };

    function HC_updateStatus(msg, isProcessing) {
        $('#status-msg').show();
        $('#status-text').text(msg);
        if(isProcessing) $('#status-msg').removeClass('text-success').addClass('text-info');
        else $('#status-msg').removeClass('text-info').addClass('text-success');

        const resStatus = $('#results-status');
        if (resStatus.length) {
            const icon = isProcessing ? '<i class="fa fa-spinner fa-spin"></i> ' : '';
            resStatus.html(icon + msg);
        }
    }

    // RENDERERS
    function HC_renderChart(data) {
        const ctx = document.getElementById('hc-horizonChart');
        if (!ctx) return;
        const canvasCtx = ctx.getContext('2d');
        if (HC_chartInstance) HC_chartInstance.destroy();
        let displayData = data.length > 720 ? data.filter((_, i) => i % 5 === 0) : data;
        const chartData = displayData.map(d => ({x: d.x, y: d.y}));
        
        HC_chartInstance = new Chart(canvasCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Horizon Profile',
                    data: chartData,
                    borderColor: '#2e8b57',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: true,
                    backgroundColor: 'rgba(46, 139, 87, 0.1)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    x: { type: 'linear', min: 0, max: 360, ticks: {stepSize: 45}, title:{display:true, text:'Bearing'} },
                    y: { title: {display:true, text:'Angle (Deg)'} }
                },
                plugins: { tooltip: { intersect: false, mode: 'index' } }
            }
        });
    }

    // Export horizon profile data to CSV
    window.HC_exportChartToCSV = function() {
        if (!HC_profileData || HC_profileData.length === 0) {
            alert('No horizon profile data available to export.');
            return;
        }

        // Create CSV header
        let csvContent = 'Azimuth (degrees),Altitude (degrees)\n';
        
        // Add data rows (azimuth, altitude pairs)
        HC_profileData.forEach(point => {
            if (point && !isNaN(point.x) && !isNaN(point.y)) {
                csvContent += `${point.x.toFixed(6)},${point.y.toFixed(6)}\n`;
            }
        });

        // Create download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        
        // Generate filename with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const lat = HC_cachedParams ? HC_cachedParams.center.lat.toFixed(6) : '0';
        const lng = HC_cachedParams ? HC_cachedParams.center.lng.toFixed(6) : '0';
        link.setAttribute('download', `horizon-profile-${lat}-${lng}-${timestamp}.csv`);
        
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    function HC_renderPanorama() {
        // Prevent multiple simultaneous renders
        if (HC_renderingPanorama) {
            HC_pendingPanoramaRender = true;
            return;
        }
        
        HC_renderingPanorama = true;
        
        // Only render panoramas if their checkboxes are checked and rows are visible
        // 1. Silhouette Panorama
        if ($('#chk-show-silhouette').is(':checked') && $('#row-visual-horizon-silhouette').is(':visible')) {
        HC_drawPano('hc-panoCanvas', HC_panoFov, HC_panoBearing, (ctx, w, h, horizonY, pxPerDegX, pxPerDegY) => {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, w, h);
            
            const grad = ctx.createLinearGradient(0, horizonY, 0, h);
            grad.addColorStop(0, '#556B2F');
            grad.addColorStop(1, '#8B4513');
            
            ctx.beginPath();
            ctx.moveTo(0, h);
            const startAngle = HC_panoBearing - (HC_panoFov / 2);
            const dataRes = 360 / HC_profileData.length;
            for (let x = 0; x <= w; x++) {
                const bearing = startAngle + (x / w) * HC_panoFov;
                let norm = (bearing % 360 + 360) % 360;
                const idx = Math.floor(norm / dataRes);
                const pt = HC_profileData[idx] || {y: 0};
                ctx.lineTo(x, horizonY - (pt.y * pxPerDegY));
            }
            ctx.lineTo(w, h);
            ctx.closePath();
            ctx.fillStyle = grad;
            ctx.fill();
        });
        }

        // 2. Hillshade Panorama
        if ($('#chk-show-hillshade').is(':checked') && $('#row-visual-horizon-hillshade').is(':visible')) {
            HC_drawPano('hc-panoCanvasHillshade', HC_panoFov, HC_panoBearing, (ctx, w, h, horizonY, pxPerDegX, pxPerDegY) => {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, w, h);
            
            const startAngle = HC_panoBearing - (HC_panoFov / 2);
            const dataRes = 360 / HC_profileData.length;
            
            // Pixel-by-pixel vertical strips
            for (let x = 0; x <= w; x++) {
                const bearing = startAngle + (x / w) * HC_panoFov;
                let norm = (bearing % 360 + 360) % 360;
                const idx = Math.floor(norm / dataRes);
                const pt = HC_profileData[idx];
                
                if (pt && pt.segments) {
                    // Draw visible segments (back-to-front rendering logic handled by calculator)
                    pt.segments.forEach(seg => {
                        const yTop = horizonY - (seg.top * pxPerDegY);
                        const yBottom = horizonY - (seg.bottom * pxPerDegY);
                        // Draw segment
                        ctx.fillStyle = seg.color || 'rgb(100,100,100)';
                        // Moiré Fix: Width 1.5 to overlap slightly
                        ctx.fillRect(x, yTop, 1.5, Math.max(1, yBottom - yTop));
                    });
                } else {
                    // Fallback for missing segments
                    const yPos = horizonY - ((pt ? pt.y : 0) * pxPerDegY);
                    ctx.fillStyle = 'rgb(100,100,100)';
                    ctx.fillRect(x, yPos, 1.5, h - yPos);
                }
            }
            });
        }
        
        // Reset rendering flag and handle pending render
        HC_renderingPanorama = false;
        if (HC_pendingPanoramaRender) {
            HC_pendingPanoramaRender = false;
            // Use requestAnimationFrame for next render to avoid blocking
            requestAnimationFrame(() => HC_renderPanorama());
        }
    }

    function HC_drawPano(id, fov, bearing, renderContent) {
        const canvas = document.getElementById(id);
        if (!canvas) {
            // Silently return if canvas doesn't exist (might be hidden)
            return;
        }
        
        // Check if canvas or its parent row is visible
        const canvasRow = $(canvas).closest('.row');
        if (canvasRow.length && !canvasRow.is(':visible')) {
            // Canvas is in a hidden row, skip rendering
            return;
        }
        
        const wrapper = canvas.parentElement;
        if(!wrapper) {
            return;
        }
        
        // Check if wrapper has dimensions - if not, it might be hidden or not yet laid out
        const wrapperWidth = wrapper.clientWidth || wrapper.offsetWidth;
        const wrapperHeight = wrapper.clientHeight || wrapper.offsetHeight;
        
        if(wrapperWidth === 0 || wrapperHeight === 0) {
            // Silently return if wrapper has no dimensions (likely hidden)
            return;
        }
        
        canvas.width = wrapperWidth;
        canvas.height = wrapperHeight;
        const w = canvas.width;
        const h = canvas.height;
        const ctx = canvas.getContext('2d');
        
        if(!HC_profileData || !HC_profileData.length) {
            return;
        }

        const pxPerDegX = w / fov;
        const pxPerDegY = h / (10 * (fov / 90));
        const horizonY = h / 2;

        renderContent(ctx, w, h, horizonY, pxPerDegX, pxPerDegY);
        HC_drawOverlays(ctx, w, h, fov, pxPerDegX, bearing, horizonY, pxPerDegY);
    }

    /**
     * Draw solar and lunar paths on panorama
     * Paths are drawn behind the horizon (below horizonY) and project upward into the sky
     * Uses calculated center of sun/moon based on declination
     */
    function HC_drawMapLine(data) {
        const map = getMap();
        if (HC_polyline) {
            map.removeLayer(HC_polyline);
            HC_polyline = null;
        }
        const latlngs = data.filter(d => d.latlng).map(d => d.latlng);
        if (latlngs.length > 0) {
            // Close the polygon by adding the first point again if not already closed
            const firstPoint = latlngs[0];
            const lastPoint = latlngs[latlngs.length - 1];
            if (firstPoint.lat !== lastPoint.lat || firstPoint.lng !== lastPoint.lng) {
                latlngs.push(firstPoint);
            }
            // Draw as polygon with mid grey outline and light grey fill
            // Make it interactive so clicks work
            HC_polyline = L.polygon(latlngs, { 
                color: '#808080', // Mid grey line color
                weight: 2, 
                opacity: 0.7,
                fillColor: '#F5F5F5', // Very light grey fill color
                fillOpacity: 0.1, // 10% fill opacity
                smoothFactor: 1,
                interactive: true
            }).addTo(map);
            
            // Store the data for click handler
            HC_polyline._viewshedData = data;
            
            // Make viewshed horizon line clickable - find nearest point and show azimuth
            HC_polyline.on('click', function(e) {
                const data = this._viewshedData || [];
                const clickLatLng = e.latlng;
                let nearestPoint = null;
                let nearestDistance = Infinity;
                let nearestAzimuth = null;
                
                // Find the nearest viewshed point to the click location
                data.forEach(point => {
                    if (!point.latlng || point.x === undefined) return;
                    
                    const distance = clickLatLng.distanceTo(point.latlng);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestPoint = point.latlng;
                        nearestAzimuth = ((point.x % 360) + 360) % 360;
                    }
                });
                
                if (nearestPoint && nearestAzimuth !== null) {
                    L.popup()
                        .setLatLng(nearestPoint)
                        .setContent(`Azimuth: ${nearestAzimuth.toFixed(3)}°<br>Lat: ${nearestPoint.lat.toFixed(6)}<br>Lng: ${nearestPoint.lng.toFixed(6)}`)
                        .openOn(map);
                }
            });
        }
    }

    // Get rise/set location data from layer groups
    function HC_getRiseSetLocations() {
        const locations = [];
        if (!window.scriptCOverlayGroups) return locations;
        
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (!layerGroup || !layerGroup.eachLayer) return;
            // Skip "0 Horizon Intersections" layer group
            if (layerGroup.layerNameForControl === "0 Horizon Intersections") {
                return;
            }
            
            layerGroup.eachLayer(function(layer) {
                if (layer instanceof L.CircleMarker) {
                    const popup = layer.getPopup();
                    const popupContent = popup ? popup.getContent() : '';
                    
                    // Extract label from popup content
                    let label = '';
                    if (popupContent) {
                        const match = popupContent.match(/<b>(.*?)<\/b>/);
                        if (match) {
                            label = match[1];
                        }
                    }
                    
                    // Extract abbreviation (e.g., "SSR", "WSR", "ER") - remove "Upper Limb", "Center", "Lower Limb", "(Minor)"
                    // Match quick view naming convention
                    let displayLabel = label;
                    if (label) {
                        // Remove "Upper Limb", "Lower Limb", "Center", "(Minor)", and "at Horizon" to get just the abbreviation
                        displayLabel = label.replace(/\s*(Upper|Lower)\s*Limb\s*/gi, '')
                                           .replace(/\s*Center\s*/gi, '')
                                           .replace(/\s*\(Minor\)\s*/gi, '')
                                           .replace(/\s*at\s*Horizon\s*/gi, '')
                                           .trim();
                    }
                    
                    // Fix incorrect labels: Major lunar sets are incorrectly labeled as "SMNLS" but should be "SMLS"
                    // ML = Major Lunar, MN = Minor Lunar (MNL is checked as substring of NMNLS/SMNLS)
                    const lowerLabel = label.toLowerCase();
                    const isMajorLunar = lowerLabel.includes('major') || 
                                        (displayLabel.includes('ML') && !displayLabel.includes('MNL'));
                    const isMinorLunar = lowerLabel.includes('minor') || 
                                       displayLabel.includes('MNL') ||
                                       (displayLabel === 'SMNLS' && !isMajorLunar);
                    
                    // Correct major lunar set labels: SMNLS (incorrect) -> SMLS (correct)
                    if (isMajorLunar && displayLabel === 'SMNLS') {
                        displayLabel = 'SMLS';
                        console.log(`Corrected label from SMNLS to SMLS for major lunar event: ${label}`);
                    }
                    // Ensure minor lunar events are correctly identified
                    if (isMinorLunar && displayLabel === 'SMNLS') {
                        // Already correct - SMNLS is the correct abbreviation for minor
                    }
                    
                    // Extract azimuth from popup content
                    let azimuth = null;
                    if (popupContent) {
                        const azMatch = popupContent.match(/Azimuth:\s*([\d.]+)/);
                        if (azMatch) {
                            azimuth = parseFloat(azMatch[1]);
                        }
                    }
                    
                    // Get fill color from marker options
                    let fillColor = layer.options.fillColor || '#000000';
                    
                    // Ensure correct colors: Minor lunar = red (#FF0000), Major lunar = dark blue (#00008B)
                    // POLYGON_COLORS[3] = '#00008B' (Major), POLYGON_COLORS[4] = '#FF0000' (Minor)
                    if (isMinorLunar) {
                        fillColor = '#FF0000'; // Red for minor lunar
                    } else if (isMajorLunar && (displayLabel.includes('ML') || displayLabel === 'SMLS')) {
                        fillColor = '#00008B'; // Dark blue for major lunar
                    }
                    
                    if (azimuth !== null && displayLabel) {
                        // Get the actual marker location (the calculated point)
                        const markerLatLng = layer.getLatLng();
                        locations.push({
                            azimuth: azimuth,
                            label: label,
                            displayLabel: displayLabel,
                            color: fillColor,
                            latlng: markerLatLng
                        });
                    }
                }
            });
        });
        
        return locations;
    }
    
    // Expose HC_getRiseSetLocations on window for export functionality
    window.HC_getRiseSetLocations = HC_getRiseSetLocations;

    // Get viewshed horizon points where pointAz > startAz AND pointAz < endAz
    function HC_getViewshedPointsBetweenAzimuths(startAz, endAz, profileData, observerLatLng) {
        const points = [];
        if (!profileData || profileData.length === 0) return points;
        
        // Normalize azimuths to 0-360
        let nStart = ((startAz % 360) + 360) % 360;
        let nEnd = ((endAz % 360) + 360) % 360;
        
        // Collect points with their azimuths for sorting
        // Use the EXACT same filtering as HC_drawMapLine: only points with latlng
        const pointsWithAz = [];
        
        profileData.forEach(profilePoint => {
            // Same check as HC_drawMapLine: filter(d => d.latlng)
            if (!profilePoint || !profilePoint.latlng) return;
            if (profilePoint.x === undefined) return;
            
            let pointAz = ((profilePoint.x % 360) + 360) % 360;
            
            // pointAz > nStart AND pointAz < nEnd
            if (pointAz > nStart && pointAz < nEnd) {
                pointsWithAz.push({ latlng: profilePoint.latlng, azimuth: pointAz });
            }
        });
        
        // Sort by azimuth in ascending order
        pointsWithAz.sort((a, b) => a.azimuth - b.azimuth);
        
        
        // Extract just the latlng values
        return pointsWithAz.map(p => p.latlng);
    }

    // Draw polylines along viewshed horizon for rise/set events
    function HC_drawRiseSetPolylines() {
        if (!HC_profileData || HC_profileData.length === 0) return;
        if (!HC_cachedParams || !HC_cachedParams.center) return;
        
        const observerLatLng = HC_cachedParams.center;
        const map = getMap();
        const riseSetLocations = HC_getRiseSetLocations();
        
        if (riseSetLocations.length === 0) return;
        
        // Group locations by event type (e.g., SSR, WSR, etc.)
        const eventGroups = new Map();
        
        riseSetLocations.forEach(loc => {
            const lowerLabel = loc.label.toLowerCase();
            // Use displayLabel directly - it already contains the correct abbreviation
            // ML = Major Lunar (e.g., NMLS = North Major Lunar Set, SMLS = South Major Lunar Set)
            // MN = Minor Lunar (e.g., NMNLS = North Minor Lunar Set, SMNLS = South Minor Lunar Set)
            const eventType = loc.displayLabel; // e.g., "SSR", "WSR", "NMLS", "SMNLS", "NMNLS"
            
            const isUpperLimb = lowerLabel.includes('upper limb');
            const isLowerLimb = lowerLabel.includes('lower limb');
            const isCenter = lowerLabel.includes('center') && !isUpperLimb && !isLowerLimb;
            // Fix isRise detection: Check for explicit "rise" OR specific rise event patterns (SSR, WSR, ER, etc.)
            // Must check for set patterns first to avoid false positives (e.g., "wss" contains 'r' from "upper")
            const isSet = lowerLabel.includes('set') || 
                         lowerLabel.includes('sss') || lowerLabel.includes('wss') ||
                         lowerLabel.includes('es') || lowerLabel.includes('ncqs') ||
                         lowerLabel.includes('scqs') || lowerLabel.includes('nmls') ||
                         lowerLabel.includes('smls') || lowerLabel.includes('nmnls') ||
                         lowerLabel.includes('smnls');
            const isRise = !isSet && (lowerLabel.includes('rise') || 
                          lowerLabel.includes('ssr') || lowerLabel.includes('wsr') ||
                          lowerLabel.includes('er') || lowerLabel.includes('ncqr') ||
                          lowerLabel.includes('scqr') || lowerLabel.includes('nmlr') ||
                          lowerLabel.includes('smlr') || lowerLabel.includes('nmnlr') ||
                          lowerLabel.includes('smnlr'));
            
            if (!eventGroups.has(eventType)) {
                eventGroups.set(eventType, {
                    upperLimb: null,
                    center: null,
                    lowerLimb: null,
                    color: loc.color,
                    isRise: isRise
                });
            }
            
            const group = eventGroups.get(eventType);
            if (isUpperLimb) {
                group.upperLimb = loc;
            } else if (isCenter) {
                group.center = loc;
            } else if (isLowerLimb) {
                group.lowerLimb = loc;
            }
        });
        
        // Draw polylines for each event
        eventGroups.forEach((group, eventType) => {
            if (!group.center) return;
            
            let justBelow, justAbove;
            if (group.isRise) {
                // For rises: Upper Limb (just below) -> Center -> Lower Limb (just above)
                justBelow = group.upperLimb;
                justAbove = group.lowerLimb;
            } else {
                // For sets: Lower Limb (just above horizon) -> Center -> Upper Limb (just below horizon)
                justAbove = group.lowerLimb;
                justBelow = group.upperLimb;
            }
            
            if (!justBelow || !justAbove) return; // Need all three points
            
            // Build polyline points: only between just below and just above, along viewshed horizon
            // Direction: RISE = clockwise from just below to just above
            //            SET = clockwise from just above to just below
            const polylinePoints = [];
            
            let startAz, endAz, startLatLng, endLatLng;
            
            if (group.isRise) {
                // RISE: from just below → just above
                startAz = justBelow.azimuth;
                endAz = justAbove.azimuth;
                // Use the actual calculated marker locations directly
                startLatLng = justBelow.latlng;
                endLatLng = justAbove.latlng;
            } else {
                // SET: from Lower Limb (just above horizon) → Upper Limb (just below horizon)
                startAz = justAbove.azimuth;
                endAz = justBelow.azimuth;
                startLatLng = justAbove.latlng;
                endLatLng = justBelow.latlng;
            }
            
            if (!startLatLng || !endLatLng) {
                console.warn(`Missing endpoints for ${eventType}: startAz=${startAz}, endAz=${endAz}`);
                return; // Need both endpoints
            }
            
            // Validate azimuth values - they should be close together (typically < 2°)
            const azDiff = Math.abs(endAz - startAz);
            const azDiffNormalized = Math.min(azDiff, 360 - azDiff);
            
            if (azDiffNormalized > 10) {
                console.warn(`WARNING: Large azimuth difference for ${eventType}: ${azDiffNormalized.toFixed(3)}° (startAz=${startAz.toFixed(3)}°, endAz=${endAz.toFixed(3)}°). Skipping polyline.`);
                return; // Skip if azimuth difference is too large (likely incorrect grouping)
            }
            
            // Get viewshed points between start and end
            const viewshedPoints = HC_getViewshedPointsBetweenAzimuths(startAz, endAz, HC_profileData, observerLatLng);
            
            // Build polyline: start → viewshed points → end
            // For rises: justBelow → viewshed points → justAbove
            // For sets: justAbove → viewshed points → justBelow
            polylinePoints.push(startLatLng);
            polylinePoints.push(...viewshedPoints);
            polylinePoints.push(endLatLng);
            
            console.log(`Total polyline points for ${eventType}: ${polylinePoints.length}`);
            
            if (polylinePoints.length < 2) return;
            
            // Create polyline
            const polyline = L.polyline(polylinePoints, {
                color: group.color,
                weight: 2,
                opacity: 0.8,
                smoothFactor: 1
            });
            
            // Find the appropriate layer group for this event type
            let targetLayerGroup = null;
            if (window.scriptCOverlayGroups) {
                window.scriptCOverlayGroups.forEach(layerGroup => {
                    if (layerGroup && layerGroup.eachLayer) {
                        let hasMatchingMarker = false;
                        layerGroup.eachLayer(function(layer) {
                            if (layer instanceof L.CircleMarker) {
                                const popup = layer.getPopup();
                                const popupContent = popup ? popup.getContent() : '';
                                if (popupContent && popupContent.includes(eventType)) {
                                    hasMatchingMarker = true;
                                }
                            }
                        });
                        if (hasMatchingMarker && !targetLayerGroup) {
                            targetLayerGroup = layerGroup;
                        }
                    }
                });
            }
            
            // Add to layer group or create new one
            if (targetLayerGroup) {
                targetLayerGroup.addLayer(polyline);
            } else {
                // Create new layer group if none found
                const newLayerGroup = L.layerGroup([polyline]);
                newLayerGroup.layerNameForControl = `${eventType} Polylines`;
                map.addLayer(newLayerGroup);
                if (window.layersControl) {
                    window.layersControl.addOverlay(newLayerGroup, `${eventType} Polylines`);
                }
                if (!window.scriptCOverlayGroups) window.scriptCOverlayGroups = [];
                window.scriptCOverlayGroups.push(newLayerGroup);
            }
        });
    }

    // Helper function to get marker lat/lng from azimuth and label
    function HC_getMarkerLatLng(azimuth, eventType, label) {
        if (!window.scriptCOverlayGroups) return null;
        
        let foundLatLng = null;
        window.scriptCOverlayGroups.forEach(layerGroup => {
            if (layerGroup && layerGroup.eachLayer && !foundLatLng) {
                layerGroup.eachLayer(function(layer) {
                    if (layer instanceof L.CircleMarker && !foundLatLng) {
                        const popup = layer.getPopup();
                        const popupContent = popup ? popup.getContent() : '';
                        if (popupContent) {
                            // Check if this marker matches the event type and label
                            // Also check for corrected labels (e.g., SMLS instead of SMNLS for major)
                            const hasEventType = popupContent.includes(eventType);
                            // For SMLS, also check for the old incorrect label SMNLS (without Minor)
                            const hasEventTypeAlt = (eventType === 'SMLS' && popupContent.includes('SMNLS') && !popupContent.includes('Minor'));
                            const hasLabel = label && popupContent.includes(label);
                            // For SMLS, also check for old label format
                            const hasLabelAlt = (eventType === 'SMLS' && label && label.includes('SMLS') && popupContent.includes('SMNLS') && !popupContent.includes('Minor'));
                            const azMatch = popupContent.match(/Azimuth:\s*([\d.]+)/);
                            
                            if ((hasEventType || hasEventTypeAlt) && (hasLabel || hasLabelAlt) && azMatch) {
                                const markerAz = parseFloat(azMatch[1]);
                                // Normalize azimuths for comparison
                                const az1 = ((azimuth % 360) + 360) % 360;
                                const az2 = ((markerAz % 360) + 360) % 360;
                                const diff = Math.abs(az1 - az2);
                                if (diff < 0.1 || diff > 359.9) {
                                    foundLatLng = layer.getLatLng();
                                }
                            }
                        }
                    }
                });
            }
        });
        return foundLatLng;
    }

    function HC_drawOverlays(ctx, w, h, fov, pxPerDegX, currentBearing, horizonY, pxPerDegY) {
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.strokeRect(0,0,w,h);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.textAlign = 'center';
        ctx.font = '12px Arial';
        const cards = [{l:'N', d:0}, {l:'NE', d:45}, {l:'E', d:90}, {l:'SE', d:135},{l:'S', d:180}, {l:'SW', d:225}, {l:'W', d:270}, {l:'NW', d:315}];
        cards.forEach(card => {
            let diff = card.d - currentBearing;
            if (diff < -180) diff += 360;
            if (diff > 180) diff -= 360;
            if (Math.abs(diff) < (fov/2)) {
                const x = (w / 2) + (diff * pxPerDegX);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.stroke();
                ctx.fillStyle = '#000';
                ctx.fillText(card.l, x, 20);
                ctx.fillStyle = '#fff';
                ctx.fillText(card.l, x+1, 21);
            }
        });
        
        // Draw rise/set location dots and labels if enabled
        // Show all locations as color-coded dots, but only label "Center" events
        if (HC_showRiseSetLocations) {
            const riseSetLocations = HC_getRiseSetLocations();
            // Filter to only show labels for "Center" events
            const centerLocations = riseSetLocations.filter(loc => 
                loc.label.toLowerCase().includes('center') && !loc.label.toLowerCase().includes('upper') && !loc.label.toLowerCase().includes('lower')
            );
            
            // Constants for sun/moon size
            const SOLAR_SEMIDIAMETER = 0.266; // degrees (angular radius)
            const LUNAR_SEMIDIAMETER = 0.272; // degrees (angular radius)
            const SOLAR_DIAMETER = SOLAR_SEMIDIAMETER * 2; // 0.532 degrees
            const LUNAR_DIAMETER = LUNAR_SEMIDIAMETER * 2; // 0.544 degrees
            
            // Determine if event is lunar from label
            const isLunarEvent = (label) => {
                const lowerLabel = label.toLowerCase();
                return lowerLabel.includes('lunar') || lowerLabel.includes('major') || lowerLabel.includes('minor') || 
                       lowerLabel.includes('nmlr') || lowerLabel.includes('smlr') || lowerLabel.includes('nmls') || 
                       lowerLabel.includes('smnls') || lowerLabel.includes('nmnlr') || lowerLabel.includes('smnlr') ||
                       lowerLabel.includes('nmnls') || lowerLabel.includes('smnls');
            };
            
            // Calculate widest label text for consistent label box width
            // Use displayLabel (shortened) instead of full label
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            let maxLabelWidth = 0;
            centerLocations.forEach(loc => {
                const displayText = loc.displayLabel || loc.label.replace(/\s*Center\s*/gi, '').trim();
                const metrics = ctx.measureText(displayText);
                if (metrics.width > maxLabelWidth) {
                    maxLabelWidth = metrics.width;
                }
            });
            // Reduce width by half and add padding
            const labelBoxWidth = Math.max(30, (maxLabelWidth + 10) / 2); // Half width, minimum 30px
            
            // Draw all locations as color-coded dots with proper positioning
            riseSetLocations.forEach(loc => {
                let diff = loc.azimuth - currentBearing;
                if (diff < -180) diff += 360;
                if (diff > 180) diff -= 360;
                if (Math.abs(diff) < (fov/2)) {
                    const x = (w / 2) + (diff * pxPerDegX);
                    
                    // Find the altitude at this azimuth from the profile data
                    let altitude = 0;
                    if (HC_profileData && HC_profileData.length > 0) {
                        const dataRes = 360 / HC_profileData.length;
                        const index = Math.round(loc.azimuth / dataRes) % HC_profileData.length;
                        if (HC_profileData[index]) {
                            altitude = HC_profileData[index].y || 0;
                        }
                    }
                    
                    // Determine marker type from label
                    const lowerLabel = loc.label.toLowerCase();
                    const isLowerLimb = lowerLabel.includes('lower limb');
                    const isUpperLimb = lowerLabel.includes('upper limb');
                    const isCenter = lowerLabel.includes('center') && !isLowerLimb && !isUpperLimb;
                    
                    // Determine if this is a rise or set event based on label abbreviations
                    // Rises: SSR (Summer Solstice Rise), WSR (Winter Solstice Rise), ER (Equinox Rise), 
                    //        NCQR (North Cross Quarter Rise), SCQR (South Cross Quarter Rise),
                    //        NMLR (North Major Lunar Rise), SMLR (South Major Lunar Rise),
                    //        NMNLR (North Minor Lunar Rise), SMNLR (South Minor Lunar Rise)
                    // Sets: SSS (Summer Solstice Set), WSS (Winter Solstice Set), ES (Equinox Set),
                    //       NCQS (North Cross Quarter Set), SCQS (South Cross Quarter Set),
                    //       NMLS (North Major Lunar Set), SMLS (South Major Lunar Set),
                    //       NMNLS (North Minor Lunar Set), SMNLS (South Minor Lunar Set)
                    const isRise = lowerLabel.includes('ssr') || lowerLabel.includes('wsr') || 
                                   lowerLabel.includes(' er ') || lowerLabel.includes('er ') || lowerLabel.startsWith('er ') ||
                                   lowerLabel.includes('ncqr') || lowerLabel.includes('scqr') || 
                                   lowerLabel.includes('nmlr') || lowerLabel.includes('smlr') || 
                                   lowerLabel.includes('nmnlr') || lowerLabel.includes('smnlr') ||
                                   lowerLabel.includes('rise');
                    const isSet = lowerLabel.includes('sss') || lowerLabel.includes('wss') || 
                                  lowerLabel.includes(' es ') || lowerLabel.includes('es ') || lowerLabel.startsWith('es ') ||
                                  lowerLabel.includes('ncqs') || lowerLabel.includes('scqs') || 
                                  lowerLabel.includes('nmls') || lowerLabel.includes('smnls') || 
                                  lowerLabel.includes('nmnls') ||
                                  lowerLabel.includes('set');
                    
                    // Calculate marker size based on sun/moon diameter
                    const diameter = isLunarEvent(loc.label) ? LUNAR_DIAMETER : SOLAR_DIAMETER;
                    const markerRadius = (diameter * pxPerDegY) / 2; // Convert degrees to pixels
                    
                    // Calculate base y position at the horizon line (altitude = 0 is at horizonY)
                    const horizonYPos = horizonY - (altitude * pxPerDegY);
                    
                    // Position marker based on type and rise/set:
                    // For SUNRISE (from north to south order):
                    //   1. Upper Limb: Top of circle touches horizon (center BELOW horizon) - sun FIRST touches horizon
                    //   2. Center: Center of circle on horizon
                    //   3. Lower Limb: Bottom of circle touches horizon (center ABOVE horizon) - sun just FULLY above horizon
                    // For SUNSET (opposite order from north to south):
                    //   1. Lower Limb: Bottom of circle touches horizon (center ABOVE horizon) - sun starts to disappear
                    //   2. Center: Center of circle on horizon
                    //   3. Upper Limb: Top of circle touches horizon (center BELOW horizon) - sun fully disappears
                    let yPos;
                    if (isRise) {
                        // Sunrise: Upper Limb (top touches, center below) -> Center -> Lower Limb (bottom touches, center above)
                        if (isUpperLimb) {
                            yPos = horizonYPos + markerRadius; // Circle center BELOW horizon (TOP of circle touches horizon)
                        } else if (isCenter) {
                            yPos = horizonYPos; // Circle center on horizon
                        } else if (isLowerLimb) {
                            yPos = horizonYPos - markerRadius; // Circle center ABOVE horizon (BOTTOM of circle touches horizon)
                        } else {
                            yPos = horizonYPos; // Default to center
                        }
                    } else if (isSet) {
                        // Sunset: Lower Limb (bottom touches, center above) -> Center -> Upper Limb (top touches, center below)
                        if (isLowerLimb) {
                            yPos = horizonYPos - markerRadius; // Circle center ABOVE horizon (BOTTOM of circle touches horizon)
                        } else if (isCenter) {
                            yPos = horizonYPos; // Circle center on horizon
                        } else if (isUpperLimb) {
                            yPos = horizonYPos + markerRadius; // Circle center BELOW horizon (TOP of circle touches horizon)
                        } else {
                            yPos = horizonYPos; // Default to center
                        }
                    } else {
                        // Default to center if can't determine rise/set
                        yPos = horizonYPos;
                    }
                    
                    // Draw color-coded dot with 70% transparency (0.3 opacity)
                    ctx.beginPath();
                    ctx.arc(x, yPos, markerRadius, 0, 2 * Math.PI);
                    // Convert hex color to rgba with 0.3 opacity
                    let fillColor = loc.color;
                    if (loc.color && loc.color.startsWith('#')) {
                        // Hex color format: #RRGGBB or #RGB
                        const hex = loc.color.replace('#', '');
                        const r = hex.length === 3 ? parseInt(hex[0] + hex[0], 16) : parseInt(hex.substring(0, 2), 16);
                        const g = hex.length === 3 ? parseInt(hex[1] + hex[1], 16) : parseInt(hex.substring(2, 4), 16);
                        const b = hex.length === 3 ? parseInt(hex[2] + hex[2], 16) : parseInt(hex.substring(4, 6), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
                    } else {
                        // For named colors or other formats, use globalAlpha
                        ctx.globalAlpha = 0.3;
                    }
                    ctx.fillStyle = fillColor;
                    ctx.fill();
                    ctx.globalAlpha = 1.0; // Reset alpha
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            });
            
            // Draw labels and lines only for "Center" events
            centerLocations.forEach(loc => {
                let diff = loc.azimuth - currentBearing;
                if (diff < -180) diff += 360;
                if (diff > 180) diff -= 360;
                if (Math.abs(diff) < (fov/2)) {
                    const x = (w / 2) + (diff * pxPerDegX);
                    
                    // Find the altitude at this azimuth from the profile data
                    let altitude = 0;
                    if (HC_profileData && HC_profileData.length > 0) {
                        const dataRes = 360 / HC_profileData.length;
                        const index = Math.round(loc.azimuth / dataRes) % HC_profileData.length;
                        if (HC_profileData[index]) {
                            altitude = HC_profileData[index].y || 0;
                        }
                    }
                    
                    // Calculate the y position at the horizon line (altitude = 0 is at horizonY)
                    const horizonYPos = horizonY - (altitude * pxPerDegY);
                    
                    // Determine if this is a rise or set event (same logic as above)
                    const lowerLabel = loc.label.toLowerCase();
                    const locIsRise = lowerLabel.includes('ssr') || lowerLabel.includes('wsr') || 
                                     lowerLabel.includes(' er ') || lowerLabel.includes('er ') || lowerLabel.startsWith('er ') ||
                                     lowerLabel.includes('ncqr') || lowerLabel.includes('scqr') || 
                                     lowerLabel.includes('nmlr') || lowerLabel.includes('smlr') || 
                                     lowerLabel.includes('nmnlr') || lowerLabel.includes('smnlr') ||
                                     lowerLabel.includes('rise');
                    const locIsSet = lowerLabel.includes('sss') || lowerLabel.includes('wss') || 
                                    lowerLabel.includes(' es ') || lowerLabel.includes('es ') || lowerLabel.startsWith('es ') ||
                                    lowerLabel.includes('ncqs') || lowerLabel.includes('scqs') || 
                                    lowerLabel.includes('nmls') || lowerLabel.includes('smnls') || 
                                    lowerLabel.includes('nmnls') ||
                                    lowerLabel.includes('set');
                    
                    // Calculate marker center position (same logic as when drawing the circle)
                    // For Center markers, the center is always on the horizon
                    const circleCenterY = horizonYPos; // Center markers are always centered on horizon
                    
                    // Draw thin grey line starting from the circle center position
                    ctx.beginPath();
                    ctx.moveTo(x, circleCenterY);
                    ctx.lineTo(x, 0);
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw label at top with consistent width based on widest text
                    // Use displayLabel (abbreviation) instead of full label, and remove "Center" word
                    const displayText = loc.displayLabel || loc.label.replace(/\s*Center\s*/gi, '').trim();
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#000';
                    ctx.fillRect(x - (labelBoxWidth / 2), 0, labelBoxWidth, 14);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(displayText, x, 11);
                }
            });
        }
        
        ctx.beginPath();
        ctx.moveTo(0, h/2);
        ctx.lineTo(w, h/2);
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function HC_setupCanvasInteraction(id, getBF, setBF, renderFn) {
        const canvas = document.getElementById(id);
        if (!canvas) return;
        let isDragging = false;
        let startX = 0;
        let startB = 0;
        let renderTimeout = null;
        
        canvas.addEventListener('mousedown', e => {
            isDragging=true;
            startX=e.clientX;
            startB=getBF().b;
            canvas.style.cursor='ew-resize';
        });
        
        window.addEventListener('mousemove', e => {
            if(!isDragging) return;
            const dx = e.clientX - startX;
            const width = canvas.width;
            const fov = getBF().f;
            const newB = (startB - (dx * (fov/width)) + 360) % 360;
            setBF(newB, fov);
            
            // Throttle rendering - only render after mouse stops moving
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                renderFn();
            }, 16); // ~60fps max
        });
        window.addEventListener('mouseup', () => {
            isDragging=false;
            canvas.style.cursor='move';
            // Render immediately on mouseup to ensure final position is shown
            if (renderTimeout) clearTimeout(renderTimeout);
            renderFn();
        });
    }

    function HC_resetPano(type) {
        if(type==='pano' || type==='hillshade') {
            HC_panoBearing=0;
            HC_panoFov=90;
            setTimeout(() => HC_renderPanorama(), 50);
        }
    }

    // Toggle rise/set location display
    window.HC_toggleRiseSetDisplay = function() {
        HC_showRiseSetLocations = !HC_showRiseSetLocations;
        const buttons = ['#btn-show-rise-set-silhouette', '#btn-show-rise-set-hillshade'];
        buttons.forEach(btnId => {
            const btn = $(btnId);
            if (btn.length) {
                if (HC_showRiseSetLocations) {
                    btn.removeClass('btn-info').addClass('btn-success');
                    btn.html('<i class="fa fa-map-marker"></i> Hide Rise/Set Locations');
                } else {
                    btn.removeClass('btn-success').addClass('btn-info');
                    btn.html('<i class="fa fa-map-marker"></i> Show Rise/Set Locations');
                }
            }
        });
        // Re-render chart and panoramas
        if (HC_profileData && HC_profileData.length > 0) {
            HC_renderChart(HC_profileData);
        }
            HC_renderPanorama();
    };

    // Toggle astronomical paths display

    // Check for rise/set locations and show buttons
    window.HC_checkRiseSetLocations = function() {
        const locations = HC_getRiseSetLocations();
        const hasLocations = locations.length > 0;
        $('#btn-show-rise-set-silhouette, #btn-show-rise-set-hillshade').toggle(hasLocations);
    };

    // =================================================================
    // PALETTE MANAGEMENT FUNCTIONS
    // =================================================================
    function HC_rgbToHex(rgb) {
        return "#" + rgb.map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }).join("");
    }

    function HC_hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : [0, 0, 0];
    }
    
    // Define Quick Swatches (RGB)
    const HC_QUICK_SWATCHES = [
        [34,139,34], [154,205,50], [244,164,96], [205,133,63], 
        [139,69,19], [128,128,128], [255,250,250], [106,169,106]
    ];

    function HC_openPaletteModal() {
        const container = $('#hc-palette-rows');
        container.empty();
        
        // Render Rows
        HC_COLOR_STOPS.forEach((stop, index) => {
            const hex = HC_rgbToHex(stop.rgb);
            
            // Build Swatch HTML
            let swatchesHtml = '<div class="swatch-container">';
            HC_QUICK_SWATCHES.forEach(rgb => {
                const sHex = HC_rgbToHex(rgb);
                swatchesHtml += `<div class="quick-swatch" style="background:${sHex}" 
                    onclick="$('#pal-col-${index}').val('${sHex}'); $('#pal-hex-${index}').val('${sHex}');"
                    title="${sHex}"></div>`;
            });
            swatchesHtml += '</div>';
            
            // Build Mixer UI (Hidden by default)
            let mixerHtml = `
                <div id="mixer-${index}" class="palette-mixer">
                    <div class="mixer-controls">
                        <input type="color" id="mix-a-${index}" value="#34985a" oninput="HC_updateMix(${index})">
                        <input type="range" id="mix-range-${index}" min="0" max="100" value="50" class="mixer-slider" oninput="HC_updateMix(${index})">
                        <input type="color" id="mix-b-${index}" value="#88786d" oninput="HC_updateMix(${index})">
                    </div>
                    <div class="text-center small text-muted">Mix blending</div>
                </div>
            `;

            const row = `
                <div class="palette-item">
                    <div class="palette-row">
                        <input type="number" class="form-control input-sm" id="pal-lim-${index}" value="${stop.lim}">
                        <input type="color" class="form-control input-sm" id="pal-col-${index}" value="${hex}" 
                               onchange="$('#pal-hex-${index}').val(this.value)">
                        <input type="text" class="form-control input-sm" id="pal-hex-${index}" value="${hex}" readonly>
                        <i class="fa fa-flask palette-btn-mix" onclick="HC_toggleMixer(${index})" title="Open Color Mixer"></i>
                        <i class="fa fa-times palette-btn-remove" onclick="HC_removePaletteRow(${index})" title="Remove Stop"></i>
                    </div>
                    ${mixerHtml}
                </div>
            `;
            container.append(row);
        });
        
        HC_updateGradientPreview();
    }

    // MIXER FUNCTIONS
    window.HC_toggleMixer = function(index) {
        $(`#mixer-${index}`).toggleClass('active');
    };

    window.HC_updateMix = function(index) {
        const hexA = $(`#mix-a-${index}`).val();
        const hexB = $(`#mix-b-${index}`).val();
        const ratio = $(`#mix-range-${index}`).val() / 100;
        
        const rgbA = HC_hexToRgb(hexA);
        const rgbB = HC_hexToRgb(hexB);
        
        const r = Math.round(rgbA[0] * (1 - ratio) + rgbB[0] * ratio);
        const g = Math.round(rgbA[1] * (1 - ratio) + rgbB[1] * ratio);
        const b = Math.round(rgbA[2] * (1 - ratio) + rgbB[2] * ratio);
        
        const finalHex = HC_rgbToHex([r,g,b]);
        
        // Update Main Controls
        $(`#pal-col-${index}`).val(finalHex);
        $(`#pal-hex-${index}`).val(finalHex);
        HC_updateGradientPreview();
    };

    function HC_addPaletteRow() {
        // Find max limit and add 500m
        let maxLim = 0;
        HC_COLOR_STOPS.forEach(s => { if(s.lim > maxLim) maxLim = s.lim; });
        
        HC_savePalette(false); 
        HC_COLOR_STOPS.push({ lim: maxLim + 500, rgb: [128, 128, 128] });
        HC_COLOR_STOPS.sort((a,b) => a.lim - b.lim);
        HC_openPaletteModal(); 
    }

    function HC_removePaletteRow(index) {
         if (HC_COLOR_STOPS.length <= 2) { alert("Must have at least 2 stops."); return; }
         HC_savePalette(false); 
         HC_COLOR_STOPS.splice(index, 1);
         HC_openPaletteModal();
    }

    function HC_savePalette(closeModal = true) {
        const newStops = [];
        const container = document.getElementById('hc-palette-rows');
        if (!container) return;
        const items = container.getElementsByClassName('palette-item');
        
        for (let i = 0; i < items.length; i++) {
            const lim = parseFloat($(`#pal-lim-${i}`).val());
            const hex = $(`#pal-col-${i}`).val();
            if (!isNaN(lim) && hex) {
                newStops.push({ lim: lim, rgb: HC_hexToRgb(hex) });
            }
        }
        newStops.sort((a, b) => a.lim - b.lim);
        HC_COLOR_STOPS = newStops;
        
        HC_updateGradientPreview();
        
        if (closeModal && HC_marker) {
            HC_updateStatus("Palette Updated. Recalculating...", true);
            HC_executeAnalysis(HC_marker.getLatLng());
        }
    }
    
    function HC_resetPalette() {
        HC_COLOR_STOPS = JSON.parse(JSON.stringify(HC_DEFAULT_PALETTE));
        HC_openPaletteModal();
    }

    
    function HC_downloadPalette() {
         const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(HC_COLOR_STOPS, null, 2));
         const downloadAnchorNode = document.createElement('a');
         downloadAnchorNode.setAttribute("href",     dataStr);
         downloadAnchorNode.setAttribute("download", "horizon_palette.json");
         document.body.appendChild(downloadAnchorNode);
         downloadAnchorNode.click();
         downloadAnchorNode.remove();
    }
    
    function HC_triggerUpload() {
        $('#hc-palette-file').click();
    }
    
    function HC_handlePaletteFile(input) {
        const file = input.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const loaded = JSON.parse(e.target.result);
                if(Array.isArray(loaded) && loaded.every(i => typeof i.lim === 'number' && Array.isArray(i.rgb))) {
                    HC_COLOR_STOPS = loaded;
                    HC_openPaletteModal(); 
                } else { alert("Invalid palette file format."); }
            } catch(err) { alert("Error parsing file: " + err.message); }
        };
        reader.readAsText(file);
        input.value = ''; 
    }

    function HC_updateGradientPreview() {
        const preview = document.getElementById('hc-gradient-preview');
        if (!preview) return;
        if (preview.tagName !== 'CANVAS') {
            // If it's not a canvas, skip (might not be initialized yet)
            return;
        }
        const ctx = preview.getContext('2d');
        if (!ctx) return;
        
        // Get the display size
        const displayWidth = preview.offsetWidth || 300;
        const displayHeight = preview.offsetHeight || 20;
        
        // Set actual canvas size (for high DPI displays)
        const scale = window.devicePixelRatio || 1;
        preview.width = displayWidth * scale;
        preview.height = displayHeight * scale;
        ctx.scale(scale, scale);
        
        if (HC_COLOR_STOPS.length === 0) return;
        
        const maxLim = Math.max(...HC_COLOR_STOPS.map(s => s.lim));
        for (let x = 0; x < displayWidth; x++) {
            const lim = (x / displayWidth) * maxLim;
            let color = HC_COLOR_STOPS[HC_COLOR_STOPS.length-1].rgb;
            for (let i = 0; i < HC_COLOR_STOPS.length; i++) {
                if (lim < HC_COLOR_STOPS[i].lim) {
                    color = HC_COLOR_STOPS[i].rgb;
                    break;
                }
            }
            ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
            ctx.fillRect(x, 0, 1, displayHeight);
        }
    }

    // Expose palette functions globally
    window.HC_openPaletteModal = HC_openPaletteModal;
    window.HC_addPaletteRow = HC_addPaletteRow;
    window.HC_removePaletteRow = HC_removePaletteRow;
    window.HC_savePalette = HC_savePalette;
    window.HC_resetPalette = HC_resetPalette;
    window.HC_downloadPalette = HC_downloadPalette;
    window.HC_triggerUpload = HC_triggerUpload;
    window.HC_handlePaletteFile = HC_handlePaletteFile;
    
    // Expose terrain calculation functions for intervisibility analysis
    window.HC_fetchTerrainPatch = HC_fetchTerrainPatch;
    window.HC_calculateViewshed = HC_calculateViewshed;
    window.HC_getInterpolatedHeight = HC_getInterpolatedHeight;

    // =================================================================
    // CHECKBOX HANDLERS FOR PANORAMA VISIBILITY
    // =================================================================
    $(document).ready(function() {
        // Initialize palette UI (only if element exists)
        if ($('#hc-palette-rows').length > 0) {
            HC_openPaletteModal();
        }
        
        // Checkbox handlers for showing/hiding panorama types
        $('#chk-show-chart').on('change', function() {
            const row = $('#row-horizon-chart');
            if ($(this).is(':checked')) {
                row.show();
            } else {
                row.hide();
            }
        });

        $('#chk-show-silhouette').on('change', function() {
            const row = $('#row-visual-horizon-silhouette');
            if ($(this).is(':checked')) {
                row.show();
            } else {
                row.hide();
            }
        });

        $('#chk-show-hillshade').on('change', function() {
            const row = $('#row-visual-horizon-hillshade');
            if ($(this).is(':checked')) {
                row.show();
                // Force a small delay to ensure the canvas is visible before rendering
                setTimeout(() => {
                    if (HC_profileData && HC_profileData.length > 0) {
                        HC_renderPanorama();
                    }
                }, 100);
            } else {
                row.hide();
            }
        });

        // Set initial visibility based on checkbox states (defaults: Chart and Hillshade checked)
        if ($('#chk-show-chart').is(':checked')) {
            $('#row-horizon-chart').show();
        } else {
            $('#row-horizon-chart').hide();
        }
        
        if ($('#chk-show-silhouette').is(':checked')) {
            $('#row-visual-horizon-silhouette').show();
        } else {
            $('#row-visual-horizon-silhouette').hide();
        }
        
        if ($('#chk-show-hillshade').is(':checked')) {
            $('#row-visual-horizon-hillshade').show();
        } else {
            $('#row-visual-horizon-hillshade').hide();
        }
        

        // Add pan handlers for hillshade canvas
        $('#pan-left-hillshade').click(function() {
            HC_panoBearing = (HC_panoBearing - 20 + 360) % 360;
            setTimeout(() => HC_renderPanorama(), 50);
        });
        
        $('#pan-right-hillshade').click(function() {
            HC_panoBearing = (HC_panoBearing + 20) % 360;
            setTimeout(() => HC_renderPanorama(), 50);
        });

        // Setup canvas interaction for hillshade
        HC_setupCanvasInteraction('hc-panoCanvasHillshade', 
            () => ({b:HC_panoBearing,f:HC_panoFov}), 
            (b,f) => {HC_panoBearing=b; HC_panoFov=f;}, 
            HC_renderPanorama);
    });

    window.HC_resetPano = HC_resetPano;
    window.HC_openExportModal = HC_openExportModal;
    window.HC_proceedExport = HC_proceedExport;
    window.HC_renderChart = HC_renderChart;
    window.HC_renderPanorama = HC_renderPanorama;

    // =================================================================
    // RISE/SET LOCATIONS CALCULATION (Using Local Terrain Data)
    // =================================================================
    
    /**
     * Use existing declination values from the application instead of calculating
     * The application sets these in omphalopsychicsingle.js compute() function
     */
    function HC_setDeclinationValues() {
        // Only set once
        if (HC_declinationValuesSet) return;
        
        // Check if declination values already exist (from omphalopsychicsingle.js)
        if (typeof window.declinationSummerSolstice !== 'undefined' &&
            typeof window.declinationWinterSolstice !== 'undefined' &&
            typeof window.declinationEquinox !== 'undefined') {
            HC_declinationValuesSet = true;
            return; // Use existing values
        }
        
        // Fallback: Calculate if not available (shouldn't happen in normal operation)
        const OBLIQUITY = 23.44;
        window.declinationSummerSolstice = OBLIQUITY;
        window.declinationWinterSolstice = -OBLIQUITY;
        window.declinationEquinox = 0;
        const CROSS_QUARTER_DEC = OBLIQUITY * Math.sin(45 * Math.PI / 180);
        window.declinationCrossQuarterNorth = CROSS_QUARTER_DEC;
        window.declinationCrossQuarterSouth = -CROSS_QUARTER_DEC;
        const LUNAR_MAJOR_OFFSET = 5.1;
        const LUNAR_MINOR_OFFSET = 5.1;
        window.declinationMajorLunarNorth = OBLIQUITY + LUNAR_MAJOR_OFFSET;
        window.declinationMajorLunarSouth = -OBLIQUITY - LUNAR_MAJOR_OFFSET;
        window.declinationMinorLunarNorth = OBLIQUITY - LUNAR_MINOR_OFFSET;
        window.declinationMinorLunarSouth = -OBLIQUITY + LUNAR_MINOR_OFFSET;
        
        HC_declinationValuesSet = true;
    }

    function HC_setZeroHorizonAzimuths(observerLat) {
        // Only set once
        if (HC_zeroHorizonAzimuthsSet) return;
        
        // Use window variables set by omphalopsychicsingle.js (replaces form field dependency)
        // omphalopsychicsingle.js now sets these as window variables in compute()
        if (typeof window.solsticeazisumrise !== 'undefined' && window.solsticeazisumrise !== null) {
            // Values already set by omphalopsychicsingle.js as window variables
            HC_zeroHorizonAzimuthsSet = true;
            return;
        }
        
        // Fallback: Calculate if form values don't exist (shouldn't happen in normal operation)
        const latRad = observerLat * Math.PI / 180;
        
        const calcAz = (declination, isRise) => {
            if (declination === null || declination === undefined) return null;
            const decRad = declination * Math.PI / 180;
            const cosHA = -Math.tan(latRad) * Math.tan(decRad);
            if (Math.abs(cosHA) > 1) return null;
            const haRad = Math.acos(cosHA);
            const sinAz = Math.sin(haRad) * Math.cos(decRad) / Math.cos(latRad);
            const cosAz = (Math.sin(decRad) - Math.sin(latRad) * Math.cos(haRad)) / (Math.cos(latRad) * Math.sin(haRad));
            let azimuth = Math.atan2(sinAz, cosAz) * 180 / Math.PI;
            azimuth = (azimuth + 360) % 360;
            if (!isRise) azimuth = (360 - azimuth) % 360;
            return azimuth;
        };
        
        // Solstices
        window.solsticeazisumrise = calcAz(window.declinationSummerSolstice, true);
        window.solsticeazisumset = calcAz(window.declinationSummerSolstice, false);
        window.solsticeaziwinrise = calcAz(window.declinationWinterSolstice, true);
        window.solsticeaziwinset = calcAz(window.declinationWinterSolstice, false);
        
        // Equinoxes
        window.equinoxazisumrise = calcAz(window.declinationEquinox, true);
        window.equinoxazisumset = calcAz(window.declinationEquinox, false);
        
        // Cross-Quarters
        window.crossquarterazisumrise = calcAz(window.declinationCrossQuarterNorth, true);
        window.crossquarterazisumset = calcAz(window.declinationCrossQuarterNorth, false);
        window.crossquarteraziwinrise = calcAz(window.declinationCrossQuarterSouth, true);
        window.crossquarteraziwinset = calcAz(window.declinationCrossQuarterSouth, false);
        
        // Major Lunar
        window.majorazisumrise = calcAz(window.declinationMajorLunarNorth, true);
        window.majorazisumset = calcAz(window.declinationMajorLunarNorth, false);
        window.majoraziwinrise = calcAz(window.declinationMajorLunarSouth, true);
        window.majoraziwinset = calcAz(window.declinationMajorLunarSouth, false);
        
        // Minor Lunar
        window.minorazisumrise = calcAz(window.declinationMinorLunarNorth, true);
        window.minorazisumset = calcAz(window.declinationMinorLunarNorth, false);
        window.minoraziwinrise = calcAz(window.declinationMinorLunarSouth, true);
        window.minoraziwinset = calcAz(window.declinationMinorLunarSouth, false);
        
        HC_zeroHorizonAzimuthsSet = true;
    }
    
    function HC_convertProfileToHorizonData(profileData) {
        if (!profileData || profileData.length === 0) {
            return [];
        }
        
        const horizonDataMap = new Map();
        
        profileData.forEach(point => {
            if (point.latlng && !isNaN(point.x) && !isNaN(point.y)) {
                let azimuth = point.x % 360;
                if (azimuth < 0) azimuth += 360;
                
                const azimuthKey = Math.round(azimuth * 10000) / 10000;
                
                if (!horizonDataMap.has(azimuthKey) || 
                    (point.latlng.lat && point.latlng.lng && 
                     !horizonDataMap.get(azimuthKey).horizonLat)) {
                    horizonDataMap.set(azimuthKey, {
                        azimuth: azimuth,
                        altitude: point.y,
                        horizonLat: point.latlng.lat,
                        horizonLon: point.latlng.lng
                    });
                }
            }
        });
        
        const horizonData = Array.from(horizonDataMap.values());
        horizonData.sort((a, b) => a.azimuth - b.azimuth);
        
        if (horizonData.length > 0) {
            const firstAz = horizonData[0].azimuth;
            const lastAz = horizonData[horizonData.length - 1].azimuth;
            if (firstAz > 0.1 || lastAz < 359.9) {
                console.warn(`Horizon data coverage: ${firstAz.toFixed(2)}° to ${lastAz.toFixed(2)}°`);
            }
        }
        
        console.log(`Converted ${horizonData.length} clean horizon points from profile data`);
        return horizonData;
    }

    async function HC_calculateRiseSetLocations(observerLatLng, profileData) {
        const map = getMap();
        if (!profileData || profileData.length === 0) {
            alert("No profile data available. Please calculate a horizon profile first.");
            return;
        }

        HC_updateStatus("Calculating rise/set locations from terrain data...", true);

        try {
            // Use existing declination values (set by omphalopsychicsingle.js)
            HC_setDeclinationValues();
            
            HC_setZeroHorizonAzimuths(observerLatLng.lat);

            const horizonData = HC_convertProfileToHorizonData(profileData);
            
            if (horizonData.length === 0) {
                throw new Error("No valid horizon data points found.");
            }

            const obsData = await HC_fetchTerrainPatch(observerLatLng, HC_PEAK_FIND_ZOOM, 1, map);
            const observerElev = HC_getInterpolatedHeight(obsData, observerLatLng, map) || 0;
            
            const locationData = {
                latitude: observerLatLng.lat,
                longitude: observerLatLng.lng,
                elevation_amsl: observerElev + 2
            };

            let processedHorizonData = horizonData;
            if (window.deduplicateHorizonData) {
                processedHorizonData = window.deduplicateHorizonData(horizonData);
            } else {
                const seen = new Set();
                processedHorizonData = horizonData.filter(pt => {
                    const key = `${pt.horizonLat.toFixed(6)},${pt.horizonLon.toFixed(6)}`;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            }

            window.HC_horizonData = processedHorizonData;
            window.HC_locationData = locationData;
            
            if (window.HC_runHWTIPCalculations) {
                await window.HC_runHWTIPCalculations(processedHorizonData, locationData);
            } else {
                throw new Error("hwtip.js calculation function not available. Please ensure hwtip.js is fully loaded.");
            }

            const doProfile = $('#chk-profile').is(':checked');
            if (doProfile) {
                HC_updateStatus("Horizon Probe Complete. Rise/Set Calculations Complete.", false);
            } else {
                HC_updateStatus("Rise/Set Calculations Complete.", false);
            }
                // Update resolution controls after rise/set calculation (this will show the save button)
                HC_updateResolutionControls();
                
                // Draw polylines along viewshed horizon for rise/set events
                setTimeout(() => {
                    HC_drawRiseSetPolylines();
                }, 100);
                
                // Check for rise/set locations and show buttons
                setTimeout(() => {
                    HC_checkRiseSetLocations();
                    // Re-render chart if it exists to show dots
                    if (HC_profileData && HC_profileData.length > 0 && HC_chartInstance) {
                        HC_renderChart(HC_profileData);
                    }
                    // Update resolution controls
                    HC_updateResolutionControls();
                }, 500);
            
        } catch (error) {
            console.error("Error calculating rise/set locations:", error);
            HC_updateStatus("Rise/Set calculation error: " + error.message, false);
            alert("Error calculating rise/set locations: " + error.message);
        }
    }

    window.HC_clearRiseSetResults = function() {
        const map = getMap();
        
        // Clear HC_riseSetLayerGroup if it exists
        if (window.HC_riseSetLayerGroup) {
            map.removeLayer(window.HC_riseSetLayerGroup);
            window.HC_riseSetLayerGroup = null;
        }
        
        // Clear all rise/set related layer groups from scriptCOverlayGroups
        if (window.scriptCOverlayGroups && Array.isArray(window.scriptCOverlayGroups)) {
            const groupsToRemove = [];
            window.scriptCOverlayGroups.forEach(layerGroup => {
                if (layerGroup && layerGroup.layerNameForControl) {
                    const name = layerGroup.layerNameForControl;
                    // Remove Solar-Lunar Rise/Set groups, related groups, viewshed horizon, and polylines
                    if (name === "Solar-Lunar Rise/Set" || 
                        name === "Solstices" || 
                        name === "Equinoxes" || 
                        name === "Cross Quarters" ||
                        name === "Major Lunar Standstills" ||
                        name === "Minor Lunar Standstills" ||
                        name === "Viewshed Horizon Polygon" ||
                        name === "Viewshed Horizon" ||
                        (name && name.includes("Polylines"))) {
                        try {
                            map.removeLayer(layerGroup);
                            if (window.layersControl) {
                                window.layersControl.removeLayer(layerGroup);
                            }
                            groupsToRemove.push(layerGroup);
                        } catch (e) {
                            console.warn("Error removing layer group:", e);
                        }
                    }
                }
            });
            // Remove from scriptCOverlayGroups array
            groupsToRemove.forEach(group => {
                const index = window.scriptCOverlayGroups.indexOf(group);
                if (index > -1) {
                    window.scriptCOverlayGroups.splice(index, 1);
                }
            });
        }
        
        window.HC_horizonData = null;
        window.HC_locationData = null;
    };

    // External hook for backward compatibility
    function HC_startPolygonalExport() {
        HC_openExportModal();
    }
    window.HC_startPolygonalExport = HC_startPolygonalExport;
    
    /**
     * Internal function to recalculate profile at a specific resolution
     */
    async function HC_recalculateProfileInternal(latlng, targetResKey) {
        const targetConfig = HC_RES_SETTINGS[targetResKey];
        const map = getMap();
        
        // Preserve rise/set data before clearing (so we can restore it after recalculation)
        const preservedHorizonData = window.HC_horizonData ? JSON.parse(JSON.stringify(window.HC_horizonData)) : null;
        const preservedLocationData = window.HC_locationData ? JSON.parse(JSON.stringify(window.HC_locationData)) : null;
        
        // Clear old viewshed and rise/set results before recalculating
        if (HC_polyline) {
            map.removeLayer(HC_polyline);
            HC_polyline = null;
        }
        // Clear map markers but preserve the data for re-rendering
        window.HC_clearRiseSetResults();
        
        // Fetch terrain at target resolution
        const obsData = await HC_fetchTerrainPatch(latlng, HC_PEAK_FIND_ZOOM, 1, map);
        let observerH = HC_getInterpolatedHeight(obsData, latlng, map) || 0;
        
        let hybridTerrain = null;
        if (targetResKey === 'max') {
            HC_updateStatus(`Downloading base terrain (Z12)...`, true);
            const baseTileWidthKm = 40075 / Math.pow(2, 12);
            const baseRadiusTiles = Math.ceil(HC_SCAN_RADIUS_KM / baseTileWidthKm);
            
            if (!HC_cachedTerrain || HC_cachedTerrain.zoom !== 12 || !HC_cachedParams.center || HC_cachedParams.center.distanceTo(latlng) > 1000) {
                HC_cachedTerrain = await HC_fetchTerrainPatch(latlng, 12, baseRadiusTiles, map, (dl, tot) => {
                    HC_updateStatus(`Downloading Z12 tiles: ${dl}/${tot}`, true);
                });
            }
            HC_cachedParams = { center: latlng, height: observerH + 2 };
            
            const initialProfile = await HC_calculateViewshed(HC_cachedTerrain, HC_cachedParams.center, HC_cachedParams.height, targetConfig.steps, map, null);
            const horizonPoints = initialProfile.filter(p => p.latlng);
            
            if (horizonPoints.length > 0) {
                HC_updateStatus(`Downloading Z14 tiles for ${horizonPoints.length} horizon points...`, true);
                const z14Data = await HC_fetchZ14TilesForHorizonPoints(horizonPoints, map, (dl, tot) => {
                    HC_updateStatus(`Downloading Z14 tiles: ${dl}/${tot}`, true);
                });
                hybridTerrain = { base: HC_cachedTerrain, z14Data: z14Data, initialProfile: initialProfile };
                HC_cachedTerrain.hybrid = hybridTerrain;
            }
        } else {
            HC_updateStatus(`Downloading Terrain (Z${targetConfig.zoom})...`, true);
            const tileWidthKm = 40075 / Math.pow(2, targetConfig.zoom);
            const radiusTiles = Math.ceil(HC_SCAN_RADIUS_KM / tileWidthKm);
            
            if (!HC_cachedTerrain || HC_cachedTerrain.zoom !== targetConfig.zoom || !HC_cachedParams.center || HC_cachedParams.center.distanceTo(latlng) > 1000) {
                HC_cachedTerrain = await HC_fetchTerrainPatch(latlng, targetConfig.zoom, radiusTiles, map, (dl, tot) => {
                    HC_updateStatus(`Downloading tiles: ${dl}/${tot}`, true);
                });
                if (HC_cachedTerrain.hybrid) delete HC_cachedTerrain.hybrid;
            }
        }
        HC_cachedParams = { center: latlng, height: observerH + 2 };
        
        HC_updateStatus(`Recalculating Viewshed (${targetConfig.steps} steps)...`, true);
        const profile = await HC_calculateViewshed(HC_cachedTerrain, HC_cachedParams.center, HC_cachedParams.height, targetConfig.steps, map, hybridTerrain);
        HC_profileData = profile;
        
        // Update stored resolution
        HC_currentProbeRes = targetResKey;
        
        // Re-render profile visualizations
        if ($('#chk-profile').is(':checked')) {
            // Only draw viewshed on map if rise/set calculations are not also selected
            // (hwtip.js will draw it when doRiseSet is true to avoid duplication)
            if (!$('#chk-rise-set').is(':checked')) {
                HC_drawMapLine(profile);
            }
            HC_renderChart(profile);
            requestAnimationFrame(() => {
                HC_renderPanorama();
            });
        }
        
        // Restore rise/set locations if they existed before recalculation
        if (preservedHorizonData && preservedLocationData) {
            // Restore the data
            window.HC_horizonData = preservedHorizonData;
            window.HC_locationData = preservedLocationData;
            
            // Re-run the calculations to restore markers and polylines on the map
            // This will use the new profile data but with the same horizon/location data
            if (window.HC_runHWTIPCalculations) {
                // Use a small delay to ensure profile rendering is complete
                setTimeout(async () => {
                    try {
                        await window.HC_runHWTIPCalculations(preservedHorizonData, preservedLocationData);
                        // Re-draw polylines
                        if (typeof HC_drawRiseSetPolylines === 'function') {
                            setTimeout(() => {
                                HC_drawRiseSetPolylines();
                            }, 100);
                        }
                        // Re-render panorama to show the rise/set locations
                        if (typeof HC_renderPanorama === 'function') {
                            requestAnimationFrame(() => {
                                HC_renderPanorama();
                            });
                        }
                    } catch (err) {
                        console.error('Error restoring rise/set locations after profile recalculation:', err);
                    }
                }, 200);
            }
        }
        
        HC_updateStatus(`Profile upgraded to ${targetConfig.name} resolution.`, false);
        HC_updateResolutionControls();
    }
    
    /**
     * Recalculate profile/panorama at higher resolution
     * Steps up through: quick -> hires -> super -> max
     */
    window.HC_recalculateProfile = async function() {
        if (!HC_lastAnalysisLatLng) {
            alert('No previous analysis found. Please run an analysis first.');
            return;
        }
        
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const currentIndex = resOrder.indexOf(HC_currentProbeRes);
        
        if (currentIndex >= resOrder.length - 1) {
            alert('Already at maximum resolution.');
            return;
        }
        
        const nextRes = resOrder[currentIndex + 1];
        HC_updateStatus(`Recalculating profile at ${HC_RES_SETTINGS[nextRes].name} resolution...`, true);
        
        // Temporarily set probe resolution
        $('.res-chk-probe').prop('checked', false);
        $(`#res-probe-${nextRes}`).prop('checked', true);
        
        // Recalculate with profile only (no rise/set)
        const wasRiseSetChecked = $('#chk-rise-set').is(':checked');
        $('#chk-rise-set').prop('checked', false);
        $('#chk-profile').prop('checked', true);
        
        try {
            await HC_recalculateProfileInternal(HC_lastAnalysisLatLng, nextRes);
        } catch (err) {
            console.error('Error recalculating profile:', err);
            alert('Error recalculating profile: ' + err.message);
        } finally {
            // Restore rise/set checkbox state
            $('#chk-rise-set').prop('checked', wasRiseSetChecked);
        }
    };
    
    /**
     * Recalculate rise/set at higher resolution
     * Steps up through: quick -> hires -> super -> max
     * Ensures profile is at matching or higher resolution first
     */
    window.HC_recalculateRiseSet = async function() {
        if (!HC_lastAnalysisLatLng) {
            alert('No previous analysis found. Please run an analysis first.');
            return;
        }
        
        if (!HC_profileData || HC_profileData.length === 0) {
            alert('No profile data available. Please run horizon probe first.');
            return;
        }
        
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const currentIndex = resOrder.indexOf(HC_currentRiseSetRes);
        
        if (currentIndex >= resOrder.length - 1) {
            alert('Already at maximum resolution for rise/set calculations.');
            return;
        }
        
        const nextRes = resOrder[currentIndex + 1];
        const probeResOrder = resOrder.indexOf(HC_currentProbeRes);
        const riseSetResOrder = resOrder.indexOf(nextRes);
        
        // Check if probe resolution needs to be upgraded first - automatically upgrade if needed
        if (probeResOrder < riseSetResOrder) {
            const requiredProbeRes = resOrder[riseSetResOrder];
            // Automatically upgrade probe resolution first without prompting
            HC_updateStatus(`Upgrading profile to ${HC_RES_SETTINGS[requiredProbeRes].name} resolution for rise/set calculation...`, true);
            $('.res-chk-probe').prop('checked', false);
            $(`#res-probe-${requiredProbeRes}`).prop('checked', true);
            
            const wasRiseSetChecked = $('#chk-rise-set').is(':checked');
            $('#chk-rise-set').prop('checked', false);
            $('#chk-profile').prop('checked', true);
            
            try {
                await HC_recalculateProfileInternal(HC_lastAnalysisLatLng, requiredProbeRes);
            } finally {
                $('#chk-rise-set').prop('checked', wasRiseSetChecked);
            }
        }
        
        // Now recalculate rise/set at higher resolution
        HC_updateStatus(`Recalculating rise/set at ${HC_RES_SETTINGS[nextRes].name} resolution...`, true);
        
        // Clear old rise/set results before recalculating
        if (window.HC_riseSetLayerGroup) {
            window.HC_clearRiseSetResults();
        }
        
        // Temporarily set rise/set resolution
        $('.res-chk-riseset').prop('checked', false);
        $(`#res-riseset-${nextRes}`).prop('checked', true);
        
        // Update stored resolution
        HC_currentRiseSetRes = nextRes;
        
        // Recalculate rise/set with current profile data (which should be at correct resolution now)
        if (HC_profileData && HC_profileData.length > 0) {
            await HC_calculateRiseSetLocations(HC_lastAnalysisLatLng, HC_profileData);
        } else {
            // If no profile data, need to recalculate everything
            $('#chk-profile').prop('checked', true);
            $('#chk-rise-set').prop('checked', true);
            await HC_executeAnalysis(HC_lastAnalysisLatLng);
        }
        
        HC_updateResolutionControls();
    };
    
    /**
     * Update resolution display and upgrade buttons based on current resolutions
     */
    function HC_updateResolutionControls() {
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const resNames = {
            'quick': 'Quick',
            'hires': 'Hi-Res',
            'super': 'Super',
            'max': 'Max'
        };
        
        const probeResOrder = resOrder.indexOf(HC_currentProbeRes);
        const riseSetResOrder = resOrder.indexOf(HC_currentRiseSetRes);
        
        // Update Horizon Profile section
        const currentProfileRes = $('#current-profile-resolution');
        if (HC_profileData && HC_profileData.length > 0 && probeResOrder >= 0) {
            currentProfileRes.text(resNames[HC_currentProbeRes] || HC_currentProbeRes);
            $('#profile-resolution-buttons').show();
            // Show Save Horizon Profile button when profile is calculated
            $('#btn-save-horizon-profile').show().prop('disabled', false);
            
            // Show buttons for resolutions higher than current
            $('#btn-profile-hires').hide();
            $('#btn-profile-super').hide();
            $('#btn-profile-max').hide();
            
            if (probeResOrder < resOrder.indexOf('hires')) {
                $('#btn-profile-hires').show();
            }
            if (probeResOrder < resOrder.indexOf('super')) {
                $('#btn-profile-super').show();
            }
            if (probeResOrder < resOrder.indexOf('max')) {
                $('#btn-profile-max').show();
            }
        } else {
            currentProfileRes.text('Not Calculated');
            $('#profile-resolution-buttons').hide();
            $('#btn-save-horizon-profile').hide();
        }
        
        // Update Rise/Set section
        const currentRiseSetRes = $('#current-riseset-resolution');
        // Check if rise/set has been calculated (by checking if horizon data exists)
        if (window.HC_horizonData && window.HC_horizonData.length > 0 && riseSetResOrder >= 0) {
            currentRiseSetRes.text(resNames[HC_currentRiseSetRes] || HC_currentRiseSetRes);
            $('#riseset-resolution-buttons').show();
            // Show Save Rise/Set Locations button when rise/set is calculated
            $('#btn-save-rise-set').show().prop('disabled', false);
            
            // Show buttons for resolutions higher than current
            $('#btn-riseset-hires').hide();
            $('#btn-riseset-super').hide();
            $('#btn-riseset-max').hide();
            
            if (riseSetResOrder < resOrder.indexOf('hires')) {
                $('#btn-riseset-hires').show();
            }
            if (riseSetResOrder < resOrder.indexOf('super')) {
                $('#btn-riseset-super').show();
            }
            if (riseSetResOrder < resOrder.indexOf('max')) {
                $('#btn-riseset-max').show();
            }
        } else {
            currentRiseSetRes.text('Not Calculated');
            $('#riseset-resolution-buttons').hide();
            $('#btn-save-rise-set').hide();
        }
    }
    
    /**
     * Upgrade profile resolution to a specific level
     */
    window.HC_upgradeProfileResolution = async function(targetRes) {
        if (!HC_lastAnalysisLatLng) {
            alert('No previous analysis found. Please run an analysis first.');
            return;
        }
        
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const currentIndex = resOrder.indexOf(HC_currentProbeRes);
        const targetIndex = resOrder.indexOf(targetRes);
        
        if (targetIndex <= currentIndex) {
            alert(`Profile is already at ${HC_RES_SETTINGS[HC_currentProbeRes].name} or higher resolution.`);
            return;
        }
        
        if (targetIndex < 0) {
            alert('Invalid resolution target.');
            return;
        }
        
        // Temporarily set probe resolution
        $('.res-chk-probe').prop('checked', false);
        $(`#res-probe-${targetRes}`).prop('checked', true);
        
        try {
            await HC_recalculateProfileInternal(HC_lastAnalysisLatLng, targetRes);
        } catch (err) {
            console.error('Error upgrading profile resolution:', err);
            alert('Error upgrading profile resolution: ' + err.message);
        }
    };
    
    /**
     * Upgrade rise/set resolution to a specific level
     */
    window.HC_upgradeRiseSetResolution = async function(targetRes) {
        if (!HC_lastAnalysisLatLng) {
            alert('No previous analysis found. Please run an analysis first.');
            return;
        }
        
        if (!HC_profileData || HC_profileData.length === 0) {
            alert('No profile data available. Please run horizon probe first.');
            return;
        }
        
        const resOrder = ['quick', 'hires', 'super', 'max'];
        const currentIndex = resOrder.indexOf(HC_currentRiseSetRes);
        const targetIndex = resOrder.indexOf(targetRes);
        const probeResOrder = resOrder.indexOf(HC_currentProbeRes);
        
        if (targetIndex <= currentIndex) {
            alert(`Rise/Set is already at ${HC_RES_SETTINGS[HC_currentRiseSetRes].name} or higher resolution.`);
            return;
        }
        
        if (targetIndex < 0) {
            alert('Invalid resolution target.');
            return;
        }
        
        // Check if profile needs to be upgraded first - automatically upgrade if needed
        if (probeResOrder < targetIndex) {
            const requiredProbeRes = resOrder[targetIndex];
            // Automatically upgrade probe resolution first without prompting
            HC_updateStatus(`Upgrading profile to ${HC_RES_SETTINGS[requiredProbeRes].name} resolution for rise/set calculation...`, true);
            $('.res-chk-probe').prop('checked', false);
            $(`#res-probe-${requiredProbeRes}`).prop('checked', true);
            
            try {
                await HC_recalculateProfileInternal(HC_lastAnalysisLatLng, requiredProbeRes);
            } catch (err) {
                console.error('Error upgrading profile resolution:', err);
                alert('Error upgrading profile resolution: ' + err.message);
                return;
            }
        }
        
        // Now upgrade rise/set resolution
        HC_updateStatus(`Upgrading rise/set to ${HC_RES_SETTINGS[targetRes].name} resolution...`, true);
        
        // Temporarily set rise/set resolution
        $('.res-chk-riseset').prop('checked', false);
        $(`#res-riseset-${targetRes}`).prop('checked', true);
        
        // Update stored resolution
        HC_currentRiseSetRes = targetRes;
        
        // Clear old rise/set results before recalculating (always clear, not conditional)
        window.HC_clearRiseSetResults();
        
        // Recalculate rise/set with current profile data
        if (HC_profileData && HC_profileData.length > 0) {
            await HC_calculateRiseSetLocations(HC_lastAnalysisLatLng, HC_profileData);
        } else {
            // If no profile data, need to recalculate everything
            $('#chk-profile').prop('checked', true);
            $('#chk-rise-set').prop('checked', true);
            await HC_executeAnalysis(HC_lastAnalysisLatLng);
        }
        
        HC_updateResolutionControls();
    };

})();

